From 9c1792c121af14e99d7ee382f22e3b6d42d50dba Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Thu, 4 Jan 2018 20:50:08 -0600
Subject: [PATCH] AsyncTabCompleteEvent

Let plugins be able to control tab completion of commands and chat async.

This will be useful for frameworks like ACF so we can define async safe completion handlers,
and avoid going to main for tab completions.

Especially useful if you need to query a database in order to obtain the results for tab
completion, such as offline players.

Also adds isCommand and getLocation to the sync TabCompleteEvent

diff --git a/src/main/java/net/minecraft/network/NetHandlerPlayServer.java b/src/main/java/net/minecraft/network/NetHandlerPlayServer.java
index e7ea9b7..b2d134c 100644
--- a/src/main/java/net/minecraft/network/NetHandlerPlayServer.java
+++ b/src/main/java/net/minecraft/network/NetHandlerPlayServer.java
@@ -2,6 +2,7 @@ package net.minecraft.network;
 
 import com.destroystokyo.paper.event.player.IllegalPacketEvent;
 import com.destroystokyo.paper.event.player.PlayerJumpEvent; // Paper
+import com.destroystokyo.paper.util.MCUtil;
 import com.google.common.base.Charsets;
 import com.google.common.collect.Lists;
 import com.google.common.primitives.Doubles;
@@ -2517,21 +2518,48 @@ public class NetHandlerPlayServer implements INetHandlerPlayServer, ITickable {
     }
 
     public void processTabComplete(CPacketTabComplete packetIn) {
-        PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
-
+        // Paper start - async tab completion
         if (chatSpamField.addAndGet(this, 10) > 500
                 && !this.serverController.getPlayerList().canSendCommands(this.player.getGameProfile())) {
-            this.disconnect(new TextComponentTranslation("disconnect.spam", new Object[0]));
+            serverController.addScheduledTask(() -> this.disconnect(new TextComponentTranslation("disconnect.spam", new Object[0])));
         } else {
-            ArrayList arraylist = Lists.newArrayList();
+            com.destroystokyo.paper.event.server.AsyncTabCompleteEvent event;
+            java.util.List<String> completions = new ArrayList<>();
+            BlockPos blockpos = packetIn.getTargetBlock();
+            String buffer = packetIn.getMessage();
+            boolean isCommand = buffer.startsWith("/") || packetIn.hasTargetBlock();
+            event = new com.destroystokyo.paper.event.server.AsyncTabCompleteEvent(this.getPlayer(), completions,
+                    buffer, isCommand, blockpos != null ? MCUtil.toLocation(player.world, blockpos) : null);
+            event.callEvent();
+            completions = event.isCancelled() ? com.google.common.collect.ImmutableList.of() : event.getCompletions();
+            if (event.isCancelled() || event.isHandled()) {
+                // Still fire sync event with the provided completions, if someone is listening
+                if (!event.isCancelled() && org.bukkit.event.server.TabCompleteEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                    java.util.List<String> finalCompletions = completions;
+                    Waitable<java.util.List<String>> syncCompletions = new Waitable<java.util.List<String>>() {
+                        @Override
+                        protected java.util.List<String> evaluate() {
+                            org.bukkit.event.server.TabCompleteEvent syncEvent = new org.bukkit.event.server.TabCompleteEvent(NetHandlerPlayServer.this.getPlayer(), buffer, finalCompletions, isCommand, blockpos != null ? MCUtil.toLocation(player.world, blockpos) : null);
+                            return syncEvent.callEvent() ? syncEvent.getCompletions() : com.google.common.collect.ImmutableList.of();
+                        }
+                    };
+                    server.getServer().processQueue.add(syncCompletions);
+                    try {
+                        completions = syncCompletions.get();
+                    } catch (InterruptedException | ExecutionException e1) {
+                        e1.printStackTrace();
+                    }
+                }
 
-            for (String s :
-                    this.serverController.getTabCompletions(
-                            this.player, packetIn.getMessage(), packetIn.getTargetBlock(), packetIn.hasTargetBlock())) {
-                arraylist.add(s);
+                this.player.connection.sendPacket(new SPacketTabComplete(completions.toArray(new String[completions.size()])));
+                return;
             }
 
-            this.player.connection.sendPacket(new SPacketTabComplete((String[]) arraylist.toArray(new String[arraylist.size()])));
+            serverController.addScheduledTask(() -> {
+                java.util.List<String> syncCompletions = this.serverController.getTabCompletions(this.player, buffer, blockpos, isCommand);
+                this.player.connection.sendPacket(new SPacketTabComplete(syncCompletions.toArray(new String[syncCompletions.size()])));
+            });
+            // Paper end
         }
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 1c261a5..2fcc894 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit;
 
+import com.destroystokyo.paper.util.MCUtil;
 import com.google.common.base.Charsets;
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
@@ -1702,7 +1703,7 @@ public final class CraftServer implements Server {
                 offers = this.tabCompleteCommand(player, message, pos);
             }
 
-            TabCompleteEvent tabEvent = new TabCompleteEvent(player, message, offers);
+            TabCompleteEvent tabEvent = new TabCompleteEvent(player, message, offers, message.startsWith("/") || forceCommand, pos != null ? MCUtil.toLocation(((CraftWorld) player.getWorld()).getHandle(), pos) : null); // Paper
             this.getPluginManager().callEvent(tabEvent);
             return tabEvent.isCancelled() ? Collections.EMPTY_LIST : tabEvent.getCompletions();
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ConsoleCommandCompleter.java b/src/main/java/org/bukkit/craftbukkit/command/ConsoleCommandCompleter.java
index a5e0380..8829ef0 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ConsoleCommandCompleter.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ConsoleCommandCompleter.java
@@ -26,6 +26,39 @@ public class ConsoleCommandCompleter implements Completer {
     public void complete(LineReader reader, ParsedLine line, List<Candidate> candidates) {
         final CraftServer server = this.server.server;
         final String buffer = line.line();
+        // Async Tab Complete
+        com.destroystokyo.paper.event.server.AsyncTabCompleteEvent event;
+        java.util.List<String> completions = new java.util.ArrayList<>();
+        event = new com.destroystokyo.paper.event.server.AsyncTabCompleteEvent(server.getConsoleSender(), completions,
+            buffer, true, null);
+        event.callEvent();
+        completions = event.isCancelled() ? com.google.common.collect.ImmutableList.of() : event.getCompletions();
+
+        if (event.isCancelled() || event.isHandled()) {
+            // Still fire sync event with the provided completions, if someone is listening
+            if (!event.isCancelled() && TabCompleteEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                List<String> finalCompletions = completions;
+                Waitable<List<String>> syncCompletions = new Waitable<List<String>>() {
+                    @Override
+                    protected List<String> evaluate() {
+                        org.bukkit.event.server.TabCompleteEvent syncEvent = new org.bukkit.event.server.TabCompleteEvent(server.getConsoleSender(), buffer, finalCompletions);
+                        return syncEvent.callEvent() ? syncEvent.getCompletions() : com.google.common.collect.ImmutableList.of();
+                    }
+                };
+                server.getServer().processQueue.add(syncCompletions);
+                try {
+                    completions = syncCompletions.get();
+                } catch (InterruptedException | ExecutionException e1) {
+                    e1.printStackTrace();
+                }
+            }
+
+            if (!completions.isEmpty()) {
+                candidates.addAll(completions.stream().map(Candidate::new).collect(java.util.stream.Collectors.toList()));
+            }
+            return;
+        }
+
         // Paper end
         Waitable<List<String>> waitable =
                 new Waitable<List<String>>() {
-- 
2.18.0

