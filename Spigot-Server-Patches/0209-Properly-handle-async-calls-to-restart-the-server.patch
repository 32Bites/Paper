From 8ec276aa28b59b4c154c7d73f9e0b93533f816d0 Mon Sep 17 00:00:00 2001
From: Zach Brown <zach.brown@destroystokyo.com>
Date: Sun, 29 Oct 2017 18:29:50 -0400
Subject: [PATCH] Properly handle async calls to restart the server

The watchdog thread calls the server restart function asynchronously. Prior to
this change, it attempted to do several non-safe operations from the watchdog
thread, rather than the main. Specifically, because of a separate upstream change,
it causes player entities to be ticked asynchronously, among other things.

This is dangerous.

This patch moves the old handling into a synchronous variant, for calls from the
restart command, and adds separate handling for async calls, such as those from
the watchdog thread.

When calling from the watchdog thread, we cannot assume the main thread is in a
tickable state; it may be completely deadlocked. In order to handle this, we mark
the server as stopping, in order to account for situations where the server should
complete a tick reasonbly soon, i.e. 99% of cases.

Should the server not enter a state where it is stopping within 10 seconds, We
will assume that the server has in fact deadlocked and will proceed to force
kill the server.

This modification does not force restart the server should we actually enter a
deadlocked state where the server is stopping, whereas this will in most cases
exit within a reasonable amount of time, to put a fixed limit on a process that
will have plugins and worlds saving to the disk has a high potential to result
in corruption/dataloss.

diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index acb0846..558fd9b 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -128,6 +128,7 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
     public WorldServer[] mcpWorlds;
     private PlayerList playerList;
     private boolean serverRunning = true;
+    private boolean isRestarting = false; // Paper - flag to signify we're attempting to restart
     private boolean serverStopped;
     private int tickCounter;
     protected final Proxy serverProxy;
@@ -541,7 +542,7 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
         if (this.playerList != null) {
             LOGGER.info("Saving players");
             this.playerList.saveAllPlayerData();
-            this.playerList.removeAllPlayers();
+            this.playerList.removeAllPlayers(isRestarting); // Paper - Pass intent
 
             try {
                 Thread.sleep(100L);
@@ -585,8 +586,14 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
         return this.serverRunning;
     }
 
+    // Paper start - Allow passing of intent to restart
     public void initiateShutdown() {
+        this.initiateShutdown(false);
+    }
+
+    public void initiateShutdown(boolean isRestarting) {
         this.serverRunning = false;
+        this.isRestarting = isRestarting;
     }
 
     // Paper start - Further improve server tick loop
@@ -734,6 +741,7 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
             }
         }
     }
+    // Paper end
 
     public void applyServerIconToResponse(ServerStatusResponse response) {
         File file = this.getFile("server-icon.png");
diff --git a/src/main/java/net/minecraft/server/management/PlayerList.java b/src/main/java/net/minecraft/server/management/PlayerList.java
index 1a06f02..abdc897 100644
--- a/src/main/java/net/minecraft/server/management/PlayerList.java
+++ b/src/main/java/net/minecraft/server/management/PlayerList.java
@@ -1242,9 +1242,15 @@ public abstract class PlayerList {
         target.interactionManager.initializeGameType(worldIn.getWorldInfo().getGameType());
     }
 
+    // Paper start - Extract method to allow for restarting flag
     public void removeAllPlayers() {
+        this.removeAllPlayers(false);
+    }
+
+    public void removeAllPlayers(boolean isRestarting) {
         for (EntityPlayerMP player : this.playerEntityList) {
-            player.connection.disconnect(this.mcServer.server.getShutdownMessage());
+            player.connection.disconnect(!isRestarting ? this.mcServer.server.getShutdownMessage() : org.spigotmc.SpigotConfig.restartMessage); // Paper - add isRestarting flag
+            // Paper end
         }
 
         // Paper start - Remove collideRule team if it exists
diff --git a/src/main/java/org/spigotmc/RestartCommand.java b/src/main/java/org/spigotmc/RestartCommand.java
index d8a5b9f..a489b87 100644
--- a/src/main/java/org/spigotmc/RestartCommand.java
+++ b/src/main/java/org/spigotmc/RestartCommand.java
@@ -38,61 +38,103 @@ public class RestartCommand extends Command {
         AsyncCatcher.enabled = false;
 
         try {
-            if (!script.isFile()) {
+            // Paper - extract method and cleanup
+            boolean isRestarting = addShutdownHook(script);
+            if (isRestarting) {
+                System.out.println("Attempting to restart with " + SpigotConfig.restartScript);
+            } else {
                 System.out.println("Startup script '" + SpigotConfig.restartScript + "' does not exist! Stopping server.");
+            }
 
-                try {
-                    MinecraftServer.getServer().stopServer();
-                } catch (Throwable var3) {;
-                }
-            } else {
-                System.out.println("Attempting to restart with " + SpigotConfig.restartScript);
-                WatchdogThread.doStop();
+            // Stop the watchdog
+            WatchdogThread.doStop();
 
-                for (EntityPlayerMP p : MinecraftServer.getServer().getPlayerList().playerEntityList) {
-                    p.connection.disconnect(SpigotConfig.restartMessage);
-                }
+            shutdownServer(isRestarting);
+        } catch (Exception ex) {
+            ex.printStackTrace();
+        }
+    }
 
-                try {
-                    Thread.sleep(100L);
-                } catch (InterruptedException var6) {;
-                }
+    // Paper start - sync copied from above with minor changes, async added
+    private static void shutdownServer(boolean isRestarting) {
+        if (MinecraftServer.getServer().isCallingFromMinecraftThread()) {
+            // Kick all players
+            for (EntityPlayerMP p : com.google.common.collect.ImmutableList.copyOf(MinecraftServer.getServer().getPlayerList().playerEntityList)) {
+                p.connection.disconnect(SpigotConfig.restartMessage);
+            }
+            // Give the socket a chance to send the packets
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException ex) {
+            }
 
-                MinecraftServer.getServer().getServerConnection().terminateEndpoints();
+            closeSocket();
 
-                try {
-                    Thread.sleep(100L);
-                } catch (InterruptedException var5) {;
-                }
+            // Actually shutdown
+            try {
+                MinecraftServer.getServer().stopServer();
+            } catch (Throwable ignored) {
+            }
 
-                try {
-                    MinecraftServer.getServer().stopServer();
-                } catch (Throwable var4) {;
-                }
+            // Actually stop the JVM
+            System.exit(0);
 
-                Thread shutdownHook =
-                        new Thread() {
-                            public void run() {
-                                try {
-                                    String os = System.getProperty("os.name").toLowerCase(Locale.ENGLISH);
-
-                                    if (os.contains("win")) {
-                                        Runtime.getRuntime().exec("cmd /c start " + script.getPath());
-                                    } else {
-                                        Runtime.getRuntime().exec(new String[] {"sh", script.getPath()});
-                                    }
-                                } catch (Exception var2) {
-                                    var2.printStackTrace();
-                                }
-                            }
-                        };
-                shutdownHook.setDaemon(true);
-                Runtime.getRuntime().addShutdownHook(shutdownHook);
+        } else {
+            // Mark the server to shutdown at the end of the tick
+            MinecraftServer.getServer().initiateShutdown(isRestarting);
+
+
+            // wait 10 seconds to see if we're actually going to try shutdown
+            try {
+                Thread.sleep(10000);
+            } catch (InterruptedException ignored) {
             }
 
+            // Check if we've actually hit a state where the server is going to safely shutdown
+            // if we have, let the server stop as usual
+            if (MinecraftServer.getServer().isServerStopped()) return;
+
+            // If the server hasn't stopped by now, assume worse case and kill
+            closeSocket();
             System.exit(0);
-        } catch (Exception var7) {
-            var7.printStackTrace();
+        }
+    }
+
+    // Paper - Split from moved code
+    private static void closeSocket() {
+        // Close the socket so we can rebind with the new process
+        MinecraftServer.getServer().getServerConnection().terminateEndpoints();
+
+        // Give time for it to kick in
+        try {
+            Thread.sleep(100);
+        } catch (InterruptedException ex) {
+        }
+    }
+    // Paper end
+
+    // Paper - copied from above and modified to return if the hook registered
+    private static boolean addShutdownHook(final File script) {
+
+        if (script.isFile()) {
+            Thread shutdownHook = new Thread(() -> {
+                try {
+                    String os = System.getProperty("os.name").toLowerCase(Locale.ENGLISH);
+                    if (os.contains("win")) {
+                        Runtime.getRuntime().exec("cmd /c start " + script.getPath());
+                    } else {
+                        Runtime.getRuntime().exec(new String[] {"sh", script.getPath()});
+                    }
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            });
+
+            shutdownHook.setDaemon(true);
+            Runtime.getRuntime().addShutdownHook(shutdownHook);
+            return true;
+        } else {
+            return false;
         }
     }
 }
-- 
2.18.0

