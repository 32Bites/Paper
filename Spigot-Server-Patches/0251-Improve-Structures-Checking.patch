From 2163c387cd631609d7c3cb37e7fe00b447989a25 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sat, 11 Nov 2017 17:57:39 -0500
Subject: [PATCH] Improve Structures Checking

Improves performance by keying every chunk thats part of a structure to a hashmap
instead of only the first one.

This allows us to avoid iterating the entire structures value set to see
if a block position is inside of a structure.

This should have pretty decent performance improvement to any standard world
that has been around for a whilewith lots of structures due to ineffeciencies
in how MC stores structures (even unloaded chunks has structured data loaded)

diff --git a/src/main/java/net/minecraft/world/gen/structure/MapGenStructure.java b/src/main/java/net/minecraft/world/gen/structure/MapGenStructure.java
index 294cb95..bd2c05d 100644
--- a/src/main/java/net/minecraft/world/gen/structure/MapGenStructure.java
+++ b/src/main/java/net/minecraft/world/gen/structure/MapGenStructure.java
@@ -6,6 +6,7 @@ import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Random;
 import javax.annotation.Nullable;
 import net.minecraft.crash.CrashReport;
@@ -16,6 +17,7 @@ import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.ChunkPos;
+import net.minecraft.util.math.Vec3i;
 import net.minecraft.world.World;
 import net.minecraft.world.chunk.ChunkPrimer;
 import net.minecraft.world.gen.MapGenBase;
@@ -24,6 +26,7 @@ public abstract class MapGenStructure extends MapGenBase {
     private final Timing timing = MinecraftTimings.getStructureTiming(this); // Paper
     private MapGenStructureData structureData;
     protected Long2ObjectMap<StructureStart> structureMap = new Long2ObjectOpenHashMap<StructureStart>(1024);
+    protected Long2ObjectMap<StructureStart> allStructures = new Long2ObjectOpenHashMap<>(1024); // Paper - Holds ref to structures for every chunk its part of, where as the one above this only holds the vanilla oriented ones.
 
     public abstract String getStructureName();
 
@@ -38,6 +41,7 @@ public abstract class MapGenStructure extends MapGenBase {
             try {
                 if (this.canSpawnStructureAtCoords(chunkX, chunkZ)) {
                     StructureStart structurestart = this.getStructureStart(chunkX, chunkZ);
+                    populateStructure(structurestart); // Paper
                     this.structureMap.put(ChunkPos.asLong(chunkX, chunkZ), structurestart);
 
                     if (structurestart.isSizeableStructure()) {
@@ -121,6 +125,20 @@ public abstract class MapGenStructure extends MapGenBase {
 
     @Nullable
     protected StructureStart getStructureAt(BlockPos pos) {
+        // Paper start - replace method
+        StructureStart structureStart = allStructures.get(ChunkPos.asLong(pos));
+        if (structureStart != null && structureStart.isSizeableStructure() && structureStart.getBoundingBox().isVecInside(pos)) {
+            List<StructureComponent> structureComponents = structureStart.getComponents();
+            for (StructureComponent component : structureComponents) {
+                if (component.getBoundingBox().isVecInside(pos)) {
+                    return structureStart;
+                }
+            }
+        }
+
+        return null;
+        // Paper end
+        /*
         ObjectIterator objectiterator = this.structureMap.values().iterator();
 
         label31:
@@ -147,11 +165,17 @@ public abstract class MapGenStructure extends MapGenBase {
         }
 
         return null;
+        */
     }
 
     public boolean isPositionInStructure(World worldIn, BlockPos pos) {
         if (this.world == null) return false; // Paper
         this.initializeStructureData(worldIn);
+        // Paper start - Replace method
+        StructureStart structureStart = this.allStructures.get(ChunkPos.asLong(pos));
+        return structureStart != null && structureStart.isSizeableStructure() && structureStart.getBoundingBox().isVecInside(pos);
+        // Paper end
+        /*
         ObjectIterator objectiterator = this.structureMap.values().iterator();
 
         while (objectiterator.hasNext()) {
@@ -163,6 +187,7 @@ public abstract class MapGenStructure extends MapGenBase {
         }
 
         return false;
+        */
     }
 
     @Nullable
@@ -194,6 +219,7 @@ public abstract class MapGenStructure extends MapGenBase {
                             StructureStart structurestart = MapGenStructureIO.getStructureStart(nbttagcompound1, worldIn);
 
                             if (structurestart != null) {
+                                populateStructure(structurestart); // Paper
                                 this.structureMap.put(ChunkPos.asLong(i, j), structurestart);
                             }
                         }
@@ -203,6 +229,30 @@ public abstract class MapGenStructure extends MapGenBase {
         }
     }
 
+    // Paper start
+    private void populateStructure(StructureStart structurestart) {
+        for (StructureComponent component : structurestart.getComponents()) {
+            populateStructure(structurestart, component.getBoundingBox());
+        }
+
+        populateStructure(structurestart, structurestart.getBoundingBox());
+    }
+
+    private void populateStructure(StructureStart structurestart, StructureBoundingBox bb) {
+        if (bb == null) {
+            return;
+        }
+
+        final Vec3i low = new Vec3i(bb.minX, bb.minY, bb.minZ);
+        final Vec3i high = new Vec3i(bb.maxX, bb.maxY, bb.maxZ);
+        for (int x = low.getX() >> 4, maxX = high.getX() >> 4; x <= maxX; x++) {
+            for (int z = low.getZ() >> 4, maxZ = high.getZ() >> 4; z <= maxZ; z++) {
+                allStructures.put(ChunkPos.asLong(x, z), structurestart);
+            }
+        }
+    }
+    // Paper end
+
     private void setStructureStart(int chunkX, int chunkZ, StructureStart start) {
         this.structureData.writeInstance(start.writeStructureComponentsToNBT(chunkX, chunkZ), chunkX, chunkZ);
         this.structureData.markDirty();
-- 
2.18.0

