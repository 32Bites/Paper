From 8cdabc8692b7015aef37de9c8c9df52fe3ba6651 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sun, 8 Oct 2017 00:41:37 -0400
Subject: [PATCH] Improve Minecraft Hopper Performance

Removes unnecessary extra calls to .update() that are very expensive
Also reset cooldown each hopper tick that a hopper is full.
Also don't constantly clone ItemStacks without merit

diff --git a/src/main/java/net/minecraft/tileentity/TileEntity.java b/src/main/java/net/minecraft/tileentity/TileEntity.java
index 6b87083..baafd88 100644
--- a/src/main/java/net/minecraft/tileentity/TileEntity.java
+++ b/src/main/java/net/minecraft/tileentity/TileEntity.java
@@ -35,6 +35,7 @@ public abstract class TileEntity {
     protected boolean tileEntityInvalid;
     private int blockMetadata = -1;
     protected Block blockType;
+    static boolean IGNORE_TILE_UPDATES = false; // Paper
 
     private static void register(String id, Class<? extends TileEntity> clazz) {
         REGISTRY.putObject(new ResourceLocation(id), clazz);
@@ -122,6 +123,7 @@ public abstract class TileEntity {
 
     public void markDirty() {
         if (this.world != null) {
+            if (IGNORE_TILE_UPDATES) return; // Paper
             IBlockState iblockdata = this.world.getBlockState(this.pos);
             this.blockMetadata = iblockdata.getBlock().getMetaFromState(iblockdata);
             this.world.markChunkDirty(this.pos, this);
diff --git a/src/main/java/net/minecraft/tileentity/TileEntityHopper.java b/src/main/java/net/minecraft/tileentity/TileEntityHopper.java
index 9f18133..e404d7c 100644
--- a/src/main/java/net/minecraft/tileentity/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/tileentity/TileEntityHopper.java
@@ -227,12 +227,14 @@ public class TileEntityHopper extends TileEntityLockableLoot implements IHopper,
                             return false;
                         }
 
-                        int origCount = event.getItem().getAmount();
-                        ItemStack itemstack1 =
-                                putStackInInventoryAllSlots(this, iinventory, CraftItemStack.asNMSCopy(event.getItem()), enumdirection);
+                        // Paper start
+                        org.bukkit.inventory.ItemStack eventStack = event.getItem();
+                        int origCount = eventStack.getAmount(); // Spigot
+                        ItemStack itemstack1 = putStackInInventoryAllSlots(this, iinventory, CraftItemStack.asNMSCopy(eventStack), enumdirection);
+                        // Paper end
 
                         if (itemstack1.isEmpty()) {
-                            if (event.getItem().equals(oitemstack)) {
+                            if (eventStack.equals(oitemstack)) { // Paper
                                 iinventory.markDirty();
                             } else {
                                 this.setInventorySlotContents(i, itemstack);
@@ -371,12 +373,14 @@ public class TileEntityHopper extends TileEntityLockableLoot implements IHopper,
                 return false;
             }
 
-            int origCount = event.getItem().getAmount();
-            ItemStack itemstack2 =
-                    putStackInInventoryAllSlots(inventoryIn, hopper, CraftItemStack.asNMSCopy(event.getItem()), (EnumFacing) null);
+            // Paper start
+            org.bukkit.inventory.ItemStack eventStack = event.getItem();
+            int origCount = eventStack.getAmount(); // Spigot
+            ItemStack itemstack2 = putStackInInventoryAllSlots(inventoryIn, hopper, CraftItemStack.asNMSCopy(eventStack), null);
+            // Paper end
 
             if (itemstack2.isEmpty()) {
-                if (event.getItem().equals(oitemstack)) {
+                if (eventStack.equals(oitemstack)) { // Paper
                     inventoryIn.markDirty();
                 } else {
                     inventoryIn.setInventorySlotContents(index, itemstack1);
@@ -458,7 +462,9 @@ public class TileEntityHopper extends TileEntityLockableLoot implements IHopper,
             boolean flag1 = destination.isEmpty();
 
             if (itemstack1.isEmpty()) {
+                IGNORE_TILE_UPDATES = true; // Paper
                 destination.setInventorySlotContents(index, stack);
+                IGNORE_TILE_UPDATES = false; // Paper
                 stack = ItemStack.EMPTY;
                 flag = true;
             } else if (canCombine(itemstack1, stack)) {
-- 
2.18.0

