From 1d48afc2426edc72a47b80c3684a5b8a60a55ad6 Mon Sep 17 00:00:00 2001
From: stonar96 <minecraft.stonar96@gmail.com>
Date: Tue, 31 Oct 2017 19:14:54 -0400
Subject: [PATCH] Anti-Xray


diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index c927557..6c03ee7 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -1,7 +1,10 @@
 package com.destroystokyo.paper;
 
+import java.util.Arrays;
 import java.util.List;
 
+import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray.ChunkEdgeMode;
+import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray.EngineMode;
 import net.minecraft.server.MinecraftServer;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
@@ -422,4 +425,25 @@ public class PaperWorldConfig {
         disableCreeperLingeringEffect = getBoolean("disable-creeper-lingering-effect", false);
         log("Creeper lingering effect: " + disableCreeperLingeringEffect);
     }
+
+    public boolean antiXray;
+    public boolean asynchronous;
+    public EngineMode engineMode;
+    public ChunkEdgeMode chunkEdgeMode;
+    public int maxChunkSectionIndex;
+    public List<Object> hiddenBlocks;
+    public List<Object> replacementBlocks;
+    private void antiXray() {
+        antiXray = getBoolean("anti-xray.enabled", false);
+        asynchronous = true;
+        engineMode = EngineMode.getById(getInt("anti-xray.engine-mode", EngineMode.HIDE.getId()));
+        engineMode = engineMode == null ? EngineMode.HIDE : engineMode;
+        chunkEdgeMode = ChunkEdgeMode.getById(getInt("anti-xray.chunk-edge-mode", ChunkEdgeMode.DEFAULT.getId()));
+        chunkEdgeMode = chunkEdgeMode == null ? ChunkEdgeMode.DEFAULT : chunkEdgeMode;
+        maxChunkSectionIndex = getInt("anti-xray.max-chunk-section-index", 3);
+        maxChunkSectionIndex = maxChunkSectionIndex > 15 ? 15 : maxChunkSectionIndex;
+        hiddenBlocks = getList("anti-xray.hidden-blocks", Arrays.asList((Object) "gold_ore", "iron_ore", "coal_ore", "lapis_ore", "mossy_cobblestone", "obsidian", "chest", "diamond_ore", "redstone_ore", "lit_redstone_ore", "clay", "emerald_ore", "ender_chest"));
+        replacementBlocks = getList("anti-xray.replacement-blocks", Arrays.asList((Object) "stone", "planks"));
+        log("Anti-Xray: " + (antiXray ? "enabled" : "disabled") + " / Engine Mode: " + engineMode.getDescription() + " / Chunk Edge Mode: " + chunkEdgeMode.getDescription() + " / Up to " + ((maxChunkSectionIndex + 1) * 16) + " blocks");
+    }
 }
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
new file mode 100644
index 0000000..a04f8ea
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
@@ -0,0 +1,35 @@
+package com.destroystokyo.paper.antixray;
+
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.network.play.server.SPacketChunkData;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.Chunk;
+
+public class ChunkPacketBlockController {
+
+    public static final ChunkPacketBlockController NO_OPERATION_INSTANCE = new ChunkPacketBlockController();
+
+    protected ChunkPacketBlockController() {
+    }
+
+    public IBlockState[] getPredefinedBlockData(Chunk chunk, int chunkSectionIndex) {
+        return null;
+    }
+
+    public boolean onChunkPacketCreate(Chunk chunk, int chunkSectionSelector, boolean force) {
+        return true;
+    }
+
+    public SPacketMapChunkInfo getSPacketChunkData(SPacketChunkData packetChunkData, Chunk chunk, int chunkSectionSelector) {
+        return null;
+    }
+
+    public void modifyBlocks(SPacketChunkData packetPlayOutMapChunk, SPacketMapChunkInfo packetMapChunkInfo) {
+        packetPlayOutMapChunk.setReady(true);
+    }
+
+    public void updateNearbyBlocks(World world, BlockPos blockPosition) {
+
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
new file mode 100644
index 0000000..9822106
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
@@ -0,0 +1,625 @@
+package com.destroystokyo.paper.antixray;
+
+import com.destroystokyo.paper.PaperWorldConfig;
+import net.minecraft.block.Block;
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.init.Blocks;
+import net.minecraft.network.play.server.SPacketChunkData;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.BlockStateContainer;
+import net.minecraft.world.chunk.BlockStatePaletteRegistry;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.IBlockStatePalette;
+import net.minecraft.world.chunk.storage.ExtendedBlockStorage;
+import org.bukkit.World.Environment;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+public class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockController {
+
+    private static ExecutorService executorServiceInstance = null;
+    private final ExecutorService executorService;
+    private final boolean asynchronous;
+    private final EngineMode engineMode;
+    private final ChunkEdgeMode chunkEdgeMode;
+    private final int maxChunkSectionIndex;
+    private final IBlockState[] predefinedBlockData;
+    private final IBlockState[] predefinedBlockDataStone;
+    private final IBlockState[] predefinedBlockDataNetherrack;
+    private final IBlockState[] predefinedBlockDataEndStone;
+    private final int[] predefinedBlockDataBits;
+    private final int[] predefinedBlockDataBitsGlobal;
+    private final int[] predefinedBlockDataBitsStoneGlobal;
+    private final int[] predefinedBlockDataBitsNetherrackGlobal;
+    private final int[] predefinedBlockDataBitsEndStoneGlobal;
+    private final boolean[] solidGlobal = new boolean[Block.BLOCK_STATE_IDS.size()];
+    private final boolean[] obfuscateGlobal = new boolean[Block.BLOCK_STATE_IDS.size()];
+    private final ExtendedBlockStorage[] emptyNearbyChunkSections = {Chunk.NULL_BLOCK_STORAGE, Chunk.NULL_BLOCK_STORAGE, Chunk.NULL_BLOCK_STORAGE, Chunk.NULL_BLOCK_STORAGE};
+
+    public ChunkPacketBlockControllerAntiXray(PaperWorldConfig paperWorldConfig) {
+        asynchronous = paperWorldConfig.asynchronous;
+        engineMode = paperWorldConfig.engineMode;
+        chunkEdgeMode = paperWorldConfig.chunkEdgeMode;
+        maxChunkSectionIndex = paperWorldConfig.maxChunkSectionIndex;
+
+        if (asynchronous) {
+            executorService = getExecutorServiceInstance();
+        } else {
+            executorService = null;
+        }
+
+        if (engineMode == EngineMode.HIDE) {
+            predefinedBlockData = null;
+            predefinedBlockDataStone = new IBlockState[]{Blocks.STONE.getDefaultState()};
+            predefinedBlockDataNetherrack = new IBlockState[]{Blocks.NETHERRACK.getDefaultState()};
+            predefinedBlockDataEndStone = new IBlockState[]{Blocks.END_STONE.getDefaultState()};
+            predefinedBlockDataBits = new int[]{1};
+            predefinedBlockDataBitsGlobal = null;
+            predefinedBlockDataBitsStoneGlobal = new int[]{Block.BLOCK_STATE_IDS.get(Blocks.STONE.getDefaultState())};
+            predefinedBlockDataBitsNetherrackGlobal = new int[]{Block.BLOCK_STATE_IDS.get(Blocks.NETHERRACK.getDefaultState())};
+            predefinedBlockDataBitsEndStoneGlobal = new int[]{Block.BLOCK_STATE_IDS.get(Blocks.END_STONE.getDefaultState())};
+        } else {
+            Set<IBlockState> predefinedBlockDataSet = new HashSet<IBlockState>();
+
+            for (Object id : paperWorldConfig.hiddenBlocks) {
+                Block block = Block.getBlockFromName(String.valueOf(id));
+
+                if (block != null && !block.hasTileEntity()) {
+                    predefinedBlockDataSet.add(block.getDefaultState());
+                }
+            }
+
+            predefinedBlockData = predefinedBlockDataSet.size() == 0 ? new IBlockState[]{Blocks.DIAMOND_ORE.getDefaultState()} : predefinedBlockDataSet.toArray(new IBlockState[predefinedBlockDataSet.size()]);
+            predefinedBlockDataStone = null;
+            predefinedBlockDataNetherrack = null;
+            predefinedBlockDataEndStone = null;
+            predefinedBlockDataBits = new int[predefinedBlockData.length];
+            predefinedBlockDataBitsGlobal = new int[predefinedBlockData.length];
+            boolean containsDefaultBlockData = false;
+
+            for (int i = 0; i < predefinedBlockData.length; i++) {
+                predefinedBlockDataBits[i] = containsDefaultBlockData ? i : (containsDefaultBlockData = predefinedBlockData[i] == BlockStateContainer.AIR_BLOCK_STATE) ? 0 : i + 1;
+                predefinedBlockDataBitsGlobal[i] = Block.BLOCK_STATE_IDS.get(predefinedBlockData[i]);
+            }
+
+            predefinedBlockDataBitsStoneGlobal = null;
+            predefinedBlockDataBitsNetherrackGlobal = null;
+            predefinedBlockDataBitsEndStoneGlobal = null;
+        }
+
+        for (Object id : (engineMode == EngineMode.HIDE) ? paperWorldConfig.hiddenBlocks : paperWorldConfig.replacementBlocks) {
+            Block block = Block.getBlockFromName(String.valueOf(id));
+
+            if (block != null) {
+                obfuscateGlobal[Block.BLOCK_STATE_IDS.get(block.getDefaultState())] = true;
+            }
+        }
+
+        for (int i = 0; i < solidGlobal.length; i++) {
+            IBlockState blockData = Block.BLOCK_STATE_IDS.getByValue(i);
+
+            if (blockData != null) {
+                solidGlobal[i] = blockData.getBlock().isNormalCube(blockData) && blockData.getBlock() != Blocks.MOB_SPAWNER && blockData.getBlock() != Blocks.BARRIER;
+            }
+        }
+    }
+
+    private static ExecutorService getExecutorServiceInstance() {
+        if (executorServiceInstance == null) {
+            executorServiceInstance = Executors.newSingleThreadExecutor();
+        }
+
+        return executorServiceInstance;
+    }
+
+    @Override
+    public IBlockState[] getPredefinedBlockData(Chunk chunk, int chunkSectionIndex) {
+        // Return the block data which should be added to the data palettes so that they can be used for the obfuscation
+        if (chunkSectionIndex <= maxChunkSectionIndex) {
+            switch (engineMode) {
+                case HIDE:
+                    switch (chunk.world.getWorld().getEnvironment()) {
+                        case NETHER:
+                            return predefinedBlockDataNetherrack;
+                        case THE_END:
+                            return predefinedBlockDataEndStone;
+                        default:
+                            return predefinedBlockDataStone;
+                    }
+                default:
+                    return predefinedBlockData;
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean onChunkPacketCreate(Chunk chunk, int chunkSectionSelector, boolean force) {
+        // Load nearby chunks if necessary
+        if (chunkEdgeMode == ChunkEdgeMode.WAIT && !force) {
+            if (chunk.world.getChunkIfLoaded(chunk.x - 1, chunk.z) == null || chunk.world.getChunkIfLoaded(chunk.x + 1, chunk.z) == null || chunk.world.getChunkIfLoaded(chunk.x, chunk.z - 1) == null || chunk.world.getChunkIfLoaded(chunk.x, chunk.z + 1) == null) {
+                // Don't create the chunk packet now, wait until nearby chunks are loaded and create it later
+                return false;
+            }
+        } else if (chunkEdgeMode == ChunkEdgeMode.LOAD || chunkEdgeMode == ChunkEdgeMode.WAIT) {
+            chunk.world.getChunkFromChunkCoords(chunk.x - 1, chunk.z);
+            chunk.world.getChunkFromChunkCoords(chunk.x + 1, chunk.z);
+            chunk.world.getChunkFromChunkCoords(chunk.x, chunk.z - 1);
+            chunk.world.getChunkFromChunkCoords(chunk.x, chunk.z + 1);
+        }
+
+        // Create the chunk packet now
+        return true;
+    }
+
+    @Override
+    public SPacketChunkDataAntiXray getSPacketChunkData(SPacketChunkData packetChunkData, Chunk chunk, int chunkSectionSelector) {
+        // Return a new instance to collect data and objects in the right state while creating the chunk packet for thread safe access later
+        SPacketChunkDataAntiXray SPacketChunkDataAntiXray = new SPacketChunkDataAntiXray(packetChunkData, chunk, chunkSectionSelector, this);
+        SPacketChunkDataAntiXray.setNearbyChunks(chunk.world.getChunkIfLoaded(chunk.x - 1, chunk.z), chunk.world.getChunkIfLoaded(chunk.x + 1, chunk.z), chunk.world.getChunkIfLoaded(chunk.x, chunk.z - 1), chunk.world.getChunkIfLoaded(chunk.x, chunk.z + 1));
+        return SPacketChunkDataAntiXray;
+    }
+
+    @Override
+    public void modifyBlocks(SPacketChunkData packetChunkData, SPacketMapChunkInfo packetMapChunkInfo) {
+        if (asynchronous) {
+            executorService.submit((SPacketChunkDataAntiXray) packetMapChunkInfo);
+        } else {
+            obfuscate((SPacketChunkDataAntiXray) packetMapChunkInfo);
+        }
+    }
+
+    // Actually these fields should be variables inside the obfuscate method but in sync mode or with SingleThreadExecutor in async mode it's okay
+    private final boolean[] solid = new boolean[Block.BLOCK_STATE_IDS.size()];
+    private final boolean[] obfuscate = new boolean[Block.BLOCK_STATE_IDS.size()];
+    // These boolean arrays represent chunk layers, true means don't obfuscate, false means obfuscate
+    private boolean[][] current = new boolean[16][16];
+    private boolean[][] next = new boolean[16][16];
+    private boolean[][] nextNext = new boolean[16][16];
+    private final DataBitsReader dataBitsReader = new DataBitsReader();
+    private final DataBitsWriter dataBitsWriter = new DataBitsWriter();
+    private final ExtendedBlockStorage[] nearbyChunkSections = new ExtendedBlockStorage[4];
+
+    public void obfuscate(SPacketChunkDataAntiXray packetChunkDataAntiXray) {
+        boolean[] solidTemp = null;
+        boolean[] obfuscateTemp = null;
+        dataBitsReader.setDataBits(packetChunkDataAntiXray.getData());
+        dataBitsWriter.setDataBits(packetChunkDataAntiXray.getData());
+        int counter = 0;
+
+        for (int chunkSectionIndex = 0; chunkSectionIndex <= maxChunkSectionIndex; chunkSectionIndex++) {
+            if (packetChunkDataAntiXray.isWritten(chunkSectionIndex) && packetChunkDataAntiXray.getPredefinedBlockData(chunkSectionIndex) != null) {
+                int[] predefinedBlockDataBitsTemp = packetChunkDataAntiXray.getBlockStatePalette(chunkSectionIndex) instanceof BlockStatePaletteRegistry ? engineMode == EngineMode.HIDE ? packetChunkDataAntiXray.getChunk().world.getWorld().getEnvironment() == Environment.NETHER ? predefinedBlockDataBitsNetherrackGlobal : packetChunkDataAntiXray.getChunk().world.getWorld().getEnvironment() == Environment.THE_END ? predefinedBlockDataBitsEndStoneGlobal : predefinedBlockDataBitsStoneGlobal : predefinedBlockDataBitsGlobal : predefinedBlockDataBits;
+                dataBitsWriter.setIndex(packetChunkDataAntiXray.getDataBitsIndex(chunkSectionIndex));
+
+                // Check if the chunk section below was not obfuscated
+                if (chunkSectionIndex == 0 || !packetChunkDataAntiXray.isWritten(chunkSectionIndex - 1) || packetChunkDataAntiXray.getPredefinedBlockData(chunkSectionIndex - 1) == null) {
+                    // If so, initialize some stuff
+                    dataBitsReader.setBitsPerValue(packetChunkDataAntiXray.getBitsPerValue(chunkSectionIndex));
+                    dataBitsReader.setIndex(packetChunkDataAntiXray.getDataBitsIndex(chunkSectionIndex));
+                    solidTemp = readDataPalette(packetChunkDataAntiXray.getBlockStatePalette(chunkSectionIndex), solid, solidGlobal);
+                    obfuscateTemp = readDataPalette(packetChunkDataAntiXray.getBlockStatePalette(chunkSectionIndex), obfuscate, obfuscateGlobal);
+                    // Read the blocks of the upper layer of the chunk section below if it exists
+                    ExtendedBlockStorage belowChunkSection = null;
+                    boolean skipFirstLayer = chunkSectionIndex == 0 || (belowChunkSection = packetChunkDataAntiXray.getChunk().getBlockStorageArray()[chunkSectionIndex - 1]) == Chunk.NULL_BLOCK_STORAGE;
+
+                    for (int z = 0; z < 16; z++) {
+                        for (int x = 0; x < 16; x++) {
+                            current[z][x] = true;
+                            next[z][x] = skipFirstLayer || !solidGlobal[Block.BLOCK_STATE_IDS.get(belowChunkSection.get(x, 15, z))];
+                        }
+                    }
+
+                    // Abuse the obfuscateLayer method to read the blocks of the first layer of the current chunk section
+                    dataBitsWriter.setBitsPerValue(0);
+                    obfuscateLayer(-1, dataBitsReader, dataBitsWriter, solidTemp, obfuscateTemp, predefinedBlockDataBitsTemp, current, next, nextNext, emptyNearbyChunkSections, counter);
+                }
+
+                dataBitsWriter.setBitsPerValue(packetChunkDataAntiXray.getBitsPerValue(chunkSectionIndex));
+                nearbyChunkSections[0] = packetChunkDataAntiXray.getNearbyChunks()[0] == null ? Chunk.NULL_BLOCK_STORAGE : packetChunkDataAntiXray.getNearbyChunks()[0].getBlockStorageArray()[chunkSectionIndex];
+                nearbyChunkSections[1] = packetChunkDataAntiXray.getNearbyChunks()[1] == null ? Chunk.NULL_BLOCK_STORAGE : packetChunkDataAntiXray.getNearbyChunks()[1].getBlockStorageArray()[chunkSectionIndex];
+                nearbyChunkSections[2] = packetChunkDataAntiXray.getNearbyChunks()[2] == null ? Chunk.NULL_BLOCK_STORAGE : packetChunkDataAntiXray.getNearbyChunks()[2].getBlockStorageArray()[chunkSectionIndex];
+                nearbyChunkSections[3] = packetChunkDataAntiXray.getNearbyChunks()[3] == null ? Chunk.NULL_BLOCK_STORAGE : packetChunkDataAntiXray.getNearbyChunks()[3].getBlockStorageArray()[chunkSectionIndex];
+
+                // Obfuscate all layers of the current chunk section except the upper one
+                for (int y = 0; y < 15; y++) {
+                    boolean[][] temp = current;
+                    current = next;
+                    next = nextNext;
+                    nextNext = temp;
+                    counter = obfuscateLayer(y, dataBitsReader, dataBitsWriter, solidTemp, obfuscateTemp, predefinedBlockDataBitsTemp, current, next, nextNext, nearbyChunkSections, counter);
+                }
+
+                // Check if the chunk section above doesn't need obfuscation
+                if (chunkSectionIndex == maxChunkSectionIndex || !packetChunkDataAntiXray.isWritten(chunkSectionIndex + 1) || packetChunkDataAntiXray.getPredefinedBlockData(chunkSectionIndex + 1) == null) {
+                    // If so, obfuscate the upper layer of the current chunk section by reading blocks of the first layer from the chunk section above if it exists
+                    ExtendedBlockStorage aboveChunkSection;
+
+                    if (chunkSectionIndex != 15 && (aboveChunkSection = packetChunkDataAntiXray.getChunk().getBlockStorageArray()[chunkSectionIndex + 1]) != Chunk.NULL_BLOCK_STORAGE) {
+                        boolean[][] temp = current;
+                        current = next;
+                        next = nextNext;
+                        nextNext = temp;
+
+                        for (int z = 0; z < 16; z++) {
+                            for (int x = 0; x < 16; x++) {
+                                if (!solidGlobal[Block.BLOCK_STATE_IDS.get(aboveChunkSection.get(x, 0, z))]) {
+                                    current[z][x] = true;
+                                }
+                            }
+                        }
+
+                        // There is nothing to read anymore
+                        dataBitsReader.setBitsPerValue(0);
+                        solid[0] = true;
+                        counter = obfuscateLayer(15, dataBitsReader, dataBitsWriter, solid, obfuscateTemp, predefinedBlockDataBitsTemp, current, next, nextNext, nearbyChunkSections, counter);
+                    }
+                } else {
+                    // If not, initialize the reader and other stuff for the chunk section above to obfuscate the upper layer of the current chunk section
+                    dataBitsReader.setBitsPerValue(packetChunkDataAntiXray.getBitsPerValue(chunkSectionIndex + 1));
+                    dataBitsReader.setIndex(packetChunkDataAntiXray.getDataBitsIndex(chunkSectionIndex + 1));
+                    solidTemp = readDataPalette(packetChunkDataAntiXray.getBlockStatePalette(chunkSectionIndex + 1), solid, solidGlobal);
+                    obfuscateTemp = readDataPalette(packetChunkDataAntiXray.getBlockStatePalette(chunkSectionIndex + 1), obfuscate, obfuscateGlobal);
+                    boolean[][] temp = current;
+                    current = next;
+                    next = nextNext;
+                    nextNext = temp;
+                    counter = obfuscateLayer(15, dataBitsReader, dataBitsWriter, solidTemp, obfuscateTemp, predefinedBlockDataBitsTemp, current, next, nextNext, nearbyChunkSections, counter);
+                }
+
+                dataBitsWriter.finish();
+            }
+        }
+
+        packetChunkDataAntiXray.getSPacketChunkData().setReady(true);
+    }
+
+    private int obfuscateLayer(int y, DataBitsReader dataBitsReader, DataBitsWriter dataBitsWriter, boolean[] solid, boolean[] obfuscate, int[] predefinedBlockDataBits, boolean[][] current, boolean[][] next, boolean[][] nextNext, ExtendedBlockStorage[] nearbyChunkSections, int counter) {
+        // First block of first line
+        int dataBits = dataBitsReader.read();
+
+        if (nextNext[0][0] = !solid[dataBits]) {
+            dataBitsWriter.skip();
+            next[0][1] = true;
+            next[1][0] = true;
+        } else {
+            if (nearbyChunkSections[2] == Chunk.NULL_BLOCK_STORAGE || !solidGlobal[Block.BLOCK_STATE_IDS.get(nearbyChunkSections[2].get(0, y, 15))] || nearbyChunkSections[0] == Chunk.NULL_BLOCK_STORAGE || !solidGlobal[Block.BLOCK_STATE_IDS.get(nearbyChunkSections[0].get(15, y, 0))] || current[0][0]) {
+                dataBitsWriter.skip();
+            } else {
+                if (counter >= predefinedBlockDataBits.length) {
+                    counter = 0;
+                }
+
+                dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+            }
+        }
+
+        if (!obfuscate[dataBits]) {
+            next[0][0] = true;
+        }
+
+        // First line
+        for (int x = 1; x < 15; x++) {
+            dataBits = dataBitsReader.read();
+
+            if (nextNext[0][x] = !solid[dataBits]) {
+                dataBitsWriter.skip();
+                next[0][x - 1] = true;
+                next[0][x + 1] = true;
+                next[1][x] = true;
+            } else {
+                if (nearbyChunkSections[2] == Chunk.NULL_BLOCK_STORAGE || !solidGlobal[Block.BLOCK_STATE_IDS.get(nearbyChunkSections[2].get(x, y, 15))] || current[0][x]) {
+                    dataBitsWriter.skip();
+                } else {
+                    if (counter >= predefinedBlockDataBits.length) {
+                        counter = 0;
+                    }
+
+                    dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+                }
+            }
+
+            if (!obfuscate[dataBits]) {
+                next[0][x] = true;
+            }
+        }
+
+        // Last block of first line
+        dataBits = dataBitsReader.read();
+
+        if (nextNext[0][15] = !solid[dataBits]) {
+            dataBitsWriter.skip();
+            next[0][14] = true;
+            next[1][15] = true;
+        } else {
+            if (nearbyChunkSections[2] == Chunk.NULL_BLOCK_STORAGE || !solidGlobal[Block.BLOCK_STATE_IDS.get(nearbyChunkSections[2].get(15, y, 15))] || nearbyChunkSections[1] == Chunk.NULL_BLOCK_STORAGE || !solidGlobal[Block.BLOCK_STATE_IDS.get(nearbyChunkSections[1].get(0, y, 0))] || current[0][15]) {
+                dataBitsWriter.skip();
+            } else {
+                if (counter >= predefinedBlockDataBits.length) {
+                    counter = 0;
+                }
+
+                dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+            }
+        }
+
+        if (!obfuscate[dataBits]) {
+            next[0][15] = true;
+        }
+
+        // All inner lines
+        for (int z = 1; z < 15; z++) {
+            // First block
+            dataBits = dataBitsReader.read();
+
+            if (nextNext[z][0] = !solid[dataBits]) {
+                dataBitsWriter.skip();
+                next[z][1] = true;
+                next[z - 1][0] = true;
+                next[z + 1][0] = true;
+            } else {
+                if (nearbyChunkSections[0] == Chunk.NULL_BLOCK_STORAGE || !solidGlobal[Block.BLOCK_STATE_IDS.get(nearbyChunkSections[0].get(15, y, z))] || current[z][0]) {
+                    dataBitsWriter.skip();
+                } else {
+                    if (counter >= predefinedBlockDataBits.length) {
+                        counter = 0;
+                    }
+
+                    dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+                }
+            }
+
+            if (!obfuscate[dataBits]) {
+                next[z][0] = true;
+            }
+
+            // All inner blocks
+            for (int x = 1; x < 15; x++) {
+                dataBits = dataBitsReader.read();
+
+                if (nextNext[z][x] = !solid[dataBits]) {
+                    dataBitsWriter.skip();
+                    next[z][x - 1] = true;
+                    next[z][x + 1] = true;
+                    next[z - 1][x] = true;
+                    next[z + 1][x] = true;
+                } else {
+                    if (current[z][x]) {
+                        dataBitsWriter.skip();
+                    } else {
+                        if (counter >= predefinedBlockDataBits.length) {
+                            counter = 0;
+                        }
+
+                        dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+                    }
+                }
+
+                if (!obfuscate[dataBits]) {
+                    next[z][x] = true;
+                }
+            }
+
+            // Last block
+            dataBits = dataBitsReader.read();
+
+            if (nextNext[z][15] = !solid[dataBits]) {
+                dataBitsWriter.skip();
+                next[z][14] = true;
+                next[z - 1][15] = true;
+                next[z + 1][15] = true;
+            } else {
+                if (nearbyChunkSections[1] == Chunk.NULL_BLOCK_STORAGE || !solidGlobal[Block.BLOCK_STATE_IDS.get(nearbyChunkSections[1].get(0, y, z))] || current[z][15]) {
+                    dataBitsWriter.skip();
+                } else {
+                    if (counter >= predefinedBlockDataBits.length) {
+                        counter = 0;
+                    }
+
+                    dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+                }
+            }
+
+            if (!obfuscate[dataBits]) {
+                next[z][15] = true;
+            }
+        }
+
+        // First block of last line
+        dataBits = dataBitsReader.read();
+
+        if (nextNext[15][0] = !solid[dataBits]) {
+            dataBitsWriter.skip();
+            next[15][1] = true;
+            next[14][0] = true;
+        } else {
+            if (nearbyChunkSections[3] == Chunk.NULL_BLOCK_STORAGE || !solidGlobal[Block.BLOCK_STATE_IDS.get(nearbyChunkSections[3].get(0, y, 0))] || nearbyChunkSections[0] == Chunk.NULL_BLOCK_STORAGE || !solidGlobal[Block.BLOCK_STATE_IDS.get(nearbyChunkSections[0].get(15, y, 15))] || current[15][0]) {
+                dataBitsWriter.skip();
+            } else {
+                if (counter >= predefinedBlockDataBits.length) {
+                    counter = 0;
+                }
+
+                dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+            }
+        }
+
+        if (!obfuscate[dataBits]) {
+            next[15][0] = true;
+        }
+
+        // Last line
+        for (int x = 1; x < 15; x++) {
+            dataBits = dataBitsReader.read();
+
+            if (nextNext[15][x] = !solid[dataBits]) {
+                dataBitsWriter.skip();
+                next[15][x - 1] = true;
+                next[15][x + 1] = true;
+                next[14][x] = true;
+            } else {
+                if (nearbyChunkSections[3] == Chunk.NULL_BLOCK_STORAGE || !solidGlobal[Block.BLOCK_STATE_IDS.get(nearbyChunkSections[3].get(x, y, 0))] || current[15][x]) {
+                    dataBitsWriter.skip();
+                } else {
+                    if (counter >= predefinedBlockDataBits.length) {
+                        counter = 0;
+                    }
+
+                    dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+                }
+            }
+
+            if (!obfuscate[dataBits]) {
+                next[15][x] = true;
+            }
+        }
+
+        // Last block of last line
+        dataBits = dataBitsReader.read();
+
+        if (nextNext[15][15] = !solid[dataBits]) {
+            dataBitsWriter.skip();
+            next[15][14] = true;
+            next[14][15] = true;
+        } else {
+            if (nearbyChunkSections[3] == Chunk.NULL_BLOCK_STORAGE || !solidGlobal[Block.BLOCK_STATE_IDS.get(nearbyChunkSections[3].get(15, y, 0))] || nearbyChunkSections[1] == Chunk.NULL_BLOCK_STORAGE || !solidGlobal[Block.BLOCK_STATE_IDS.get(nearbyChunkSections[1].get(0, y, 15))] || current[15][15]) {
+                dataBitsWriter.skip();
+            } else {
+                if (counter >= predefinedBlockDataBits.length) {
+                    counter = 0;
+                }
+
+                dataBitsWriter.write(predefinedBlockDataBits[counter++]);
+            }
+        }
+
+        if (!obfuscate[dataBits]) {
+            next[15][15] = true;
+        }
+
+        return counter;
+    }
+
+    private boolean[] readDataPalette(IBlockStatePalette dataPalette, boolean[] temp, boolean[] global) {
+        if (dataPalette instanceof BlockStatePaletteRegistry) {
+            return global;
+        }
+
+        IBlockState blockData;
+
+        for (int i = 0; (blockData = dataPalette.getBlockState(i)) != null; i++) {
+            temp[i] = global[Block.BLOCK_STATE_IDS.get(blockData)];
+        }
+
+        return temp;
+    }
+
+    @Override
+    public void updateNearbyBlocks(World world, BlockPos blockPosition) {
+        BlockPos temp = blockPosition.west();
+        updateBlock(world, temp);
+        updateBlock(world, temp.west());
+        updateBlock(world, temp.down());
+        updateBlock(world, temp.up());
+        updateBlock(world, temp.north());
+        updateBlock(world, temp.south());
+        updateBlock(world, temp = blockPosition.east());
+        updateBlock(world, temp.east());
+        updateBlock(world, temp.down());
+        updateBlock(world, temp.up());
+        updateBlock(world, temp.north());
+        updateBlock(world, temp.south());
+        updateBlock(world, temp = blockPosition.down());
+        updateBlock(world, temp.down());
+        updateBlock(world, temp.north());
+        updateBlock(world, temp.south());
+        updateBlock(world, temp = blockPosition.up());
+        updateBlock(world, temp.up());
+        updateBlock(world, temp.north());
+        updateBlock(world, temp.south());
+        updateBlock(world, temp = blockPosition.north());
+        updateBlock(world, temp.north());
+        updateBlock(world, temp = blockPosition.south());
+        updateBlock(world, temp.south());
+    }
+
+    private void updateBlock(World world, BlockPos blockPosition) {
+        if (world.isBlockLoaded(blockPosition)) {
+            IBlockState blockState = world.getBlockState(blockPosition);
+
+            if (obfuscateGlobal[Block.BLOCK_STATE_IDS.get(blockState)]) {
+                world.notifyBlockUpdate(blockPosition, blockState, blockState, 3);
+            }
+        }
+    }
+
+    public enum EngineMode {
+
+        HIDE(1, "hide ores"),
+        OBFUSCATE(2, "obfuscate");
+
+        private final int id;
+        private final String description;
+
+        EngineMode(int id, String description) {
+            this.id = id;
+            this.description = description;
+        }
+
+        public static EngineMode getById(int id) {
+            for (EngineMode engineMode : values()) {
+                if (engineMode.id == id) {
+                    return engineMode;
+                }
+            }
+
+            return null;
+        }
+
+        public int getId() {
+            return id;
+        }
+
+        public String getDescription() {
+            return description;
+        }
+    }
+
+    public enum ChunkEdgeMode {
+
+        DEFAULT(1, "default"),
+        WAIT(2, "wait until nearby chunks are loaded"),
+        LOAD(3, "load nearby chunks");
+
+        private final int id;
+        private final String description;
+
+        ChunkEdgeMode(int id, String description) {
+            this.id = id;
+            this.description = description;
+        }
+
+        public static ChunkEdgeMode getById(int id) {
+            for (ChunkEdgeMode chunkEdgeMode : values()) {
+                if (chunkEdgeMode.id == id) {
+                    return chunkEdgeMode;
+                }
+            }
+
+            return null;
+        }
+
+        public int getId() {
+            return id;
+        }
+
+        public String getDescription() {
+            return description;
+        }
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/antixray/DataBitsReader.java b/src/main/java/com/destroystokyo/paper/antixray/DataBitsReader.java
new file mode 100644
index 0000000..9239931
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/DataBitsReader.java
@@ -0,0 +1,56 @@
+package com.destroystokyo.paper.antixray;
+
+public class DataBitsReader {
+
+    private byte[] dataBits;
+    private int bitsPerValue;
+    private int mask;
+    private int longInDataBitsIndex;
+    private int bitInLongIndex;
+    private long current;
+
+    public void setDataBits(byte[] dataBits) {
+        this.dataBits = dataBits;
+    }
+
+    public void setBitsPerValue(int bitsPerValue) {
+        this.bitsPerValue = bitsPerValue;
+        mask = (1 << bitsPerValue) - 1;
+    }
+
+    public void setIndex(int index) {
+        this.longInDataBitsIndex = index;
+        bitInLongIndex = 0;
+        init();
+    }
+
+    private void init() {
+        if (dataBits.length > longInDataBitsIndex + 7) {
+            current = ((((long) dataBits[longInDataBitsIndex]) << 56)
+                    | (((long) dataBits[longInDataBitsIndex + 1] & 0xff) << 48)
+                    | (((long) dataBits[longInDataBitsIndex + 2] & 0xff) << 40)
+                    | (((long) dataBits[longInDataBitsIndex + 3] & 0xff) << 32)
+                    | (((long) dataBits[longInDataBitsIndex + 4] & 0xff) << 24)
+                    | (((long) dataBits[longInDataBitsIndex + 5] & 0xff) << 16)
+                    | (((long) dataBits[longInDataBitsIndex + 6] & 0xff) << 8)
+                    | (((long) dataBits[longInDataBitsIndex + 7] & 0xff)));
+        }
+    }
+
+    public int read() {
+        int value = (int) (current >>> bitInLongIndex) & mask;
+        bitInLongIndex += bitsPerValue;
+
+        if (bitInLongIndex > 63) {
+            bitInLongIndex -= 64;
+            longInDataBitsIndex += 8;
+            init();
+
+            if (bitInLongIndex > 0) {
+                value |= current << bitsPerValue - bitInLongIndex & mask;
+            }
+        }
+
+        return value;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/antixray/DataBitsWriter.java b/src/main/java/com/destroystokyo/paper/antixray/DataBitsWriter.java
new file mode 100644
index 0000000..aca0b9d
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/DataBitsWriter.java
@@ -0,0 +1,84 @@
+package com.destroystokyo.paper.antixray;
+
+public class DataBitsWriter {
+
+    private byte[] dataBits;
+    private int bitsPerValue;
+    private long mask;
+    private int longInDataBitsIndex;
+    private int bitInLongIndex;
+    private long current;
+    private boolean dirty;
+
+    public void setDataBits(byte[] dataBits) {
+        this.dataBits = dataBits;
+    }
+
+    public void setBitsPerValue(int bitsPerValue) {
+        this.bitsPerValue = bitsPerValue;
+        mask = (1 << bitsPerValue) - 1;
+    }
+
+    public void setIndex(int index) {
+        this.longInDataBitsIndex = index;
+        bitInLongIndex = 0;
+        init();
+    }
+
+    private void init() {
+        if (dataBits.length > longInDataBitsIndex + 7) {
+            current = ((((long) dataBits[longInDataBitsIndex]) << 56)
+                    | (((long) dataBits[longInDataBitsIndex + 1] & 0xff) << 48)
+                    | (((long) dataBits[longInDataBitsIndex + 2] & 0xff) << 40)
+                    | (((long) dataBits[longInDataBitsIndex + 3] & 0xff) << 32)
+                    | (((long) dataBits[longInDataBitsIndex + 4] & 0xff) << 24)
+                    | (((long) dataBits[longInDataBitsIndex + 5] & 0xff) << 16)
+                    | (((long) dataBits[longInDataBitsIndex + 6] & 0xff) << 8)
+                    | (((long) dataBits[longInDataBitsIndex + 7] & 0xff)));
+        }
+
+        dirty = false;
+    }
+
+    public void finish() {
+        if (dirty && dataBits.length > longInDataBitsIndex + 7) {
+            dataBits[longInDataBitsIndex] = (byte) (current >> 56 & 0xff);
+            dataBits[longInDataBitsIndex + 1] = (byte) (current >> 48 & 0xff);
+            dataBits[longInDataBitsIndex + 2] = (byte) (current >> 40 & 0xff);
+            dataBits[longInDataBitsIndex + 3] = (byte) (current >> 32 & 0xff);
+            dataBits[longInDataBitsIndex + 4] = (byte) (current >> 24 & 0xff);
+            dataBits[longInDataBitsIndex + 5] = (byte) (current >> 16 & 0xff);
+            dataBits[longInDataBitsIndex + 6] = (byte) (current >> 8 & 0xff);
+            dataBits[longInDataBitsIndex + 7] = (byte) (current & 0xff);
+        }
+    }
+
+    public void write(int value) {
+        current = current & ~(mask << bitInLongIndex) | (value & mask) << bitInLongIndex;
+        dirty = true;
+        bitInLongIndex += bitsPerValue;
+
+        if (bitInLongIndex > 63) {
+            finish();
+            bitInLongIndex -= 64;
+            longInDataBitsIndex += 8;
+            init();
+
+            if (bitInLongIndex > 0) {
+                current = current & ~(mask >>> bitsPerValue - bitInLongIndex) | (value & mask) >>> bitsPerValue - bitInLongIndex;
+                dirty = true;
+            }
+        }
+    }
+
+    public void skip() {
+        bitInLongIndex += bitsPerValue;
+
+        if (bitInLongIndex > 63) {
+            finish();
+            bitInLongIndex -= 64;
+            longInDataBitsIndex += 8;
+            init();
+        }
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/antixray/SPacketChunkDataAntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/SPacketChunkDataAntiXray.java
new file mode 100644
index 0000000..f1def76
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/SPacketChunkDataAntiXray.java
@@ -0,0 +1,28 @@
+package com.destroystokyo.paper.antixray;
+
+import net.minecraft.network.play.server.SPacketChunkData;
+import net.minecraft.world.chunk.Chunk;
+
+public class SPacketChunkDataAntiXray extends SPacketMapChunkInfo implements Runnable {
+
+    private final ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray;
+    private Chunk[] nearbyChunks;
+
+    public SPacketChunkDataAntiXray(SPacketChunkData packetChunkData, Chunk chunk, int chunkSectionSelector, ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray) {
+        super(packetChunkData, chunk, chunkSectionSelector);
+        this.chunkPacketBlockControllerAntiXray = chunkPacketBlockControllerAntiXray;
+    }
+
+    public Chunk[] getNearbyChunks() {
+        return nearbyChunks;
+    }
+
+    public void setNearbyChunks(Chunk... nearbyChunks) {
+        this.nearbyChunks = nearbyChunks;
+    }
+
+    @Override
+    public void run() {
+        chunkPacketBlockControllerAntiXray.obfuscate(this);
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/antixray/SPacketMapChunkInfo.java b/src/main/java/com/destroystokyo/paper/antixray/SPacketMapChunkInfo.java
new file mode 100644
index 0000000..3df801c
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/antixray/SPacketMapChunkInfo.java
@@ -0,0 +1,80 @@
+package com.destroystokyo.paper.antixray;
+
+import net.minecraft.block.state.IBlockState;
+import net.minecraft.network.play.server.SPacketChunkData;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.IBlockStatePalette;
+
+public class SPacketMapChunkInfo {
+
+    private final SPacketChunkData packetChunkData;
+    private final Chunk chunk;
+    private final int chunkSectionSelector;
+    private final int[] bitsPerValue = new int[16];
+    private final IBlockStatePalette[] blockStatePalettes = new IBlockStatePalette[16];
+    private final int[] dataBitsIndexes = new int[16];
+    private final IBlockState[][] predefinedBlockData = new IBlockState[16][];
+    private byte[] data;
+
+    public SPacketMapChunkInfo(SPacketChunkData packetChunkData, Chunk chunk, int chunkSectionSelector) {
+        this.packetChunkData = packetChunkData;
+        this.chunk = chunk;
+        this.chunkSectionSelector = chunkSectionSelector;
+    }
+
+    public SPacketChunkData getSPacketChunkData() {
+        return packetChunkData;
+    }
+
+    public Chunk getChunk() {
+        return chunk;
+    }
+
+    public int getChunkSectionSelector() {
+        return chunkSectionSelector;
+    }
+
+    public byte[] getData() {
+        return data;
+    }
+
+    public void setData(byte[] data) {
+        this.data = data;
+    }
+
+    public int getBitsPerValue(int chunkSectionIndex) {
+        return bitsPerValue[chunkSectionIndex];
+    }
+
+    public void setBitsPerValue(int chunkSectionIndex, int bitsPerValue) {
+        this.bitsPerValue[chunkSectionIndex] = bitsPerValue;
+    }
+
+    public IBlockStatePalette getBlockStatePalette(int chunkSectionIndex) {
+        return blockStatePalettes[chunkSectionIndex];
+    }
+
+    public void setBlockStatePalette(int chunkSectionIndex, IBlockStatePalette palette) {
+        blockStatePalettes[chunkSectionIndex] = palette;
+    }
+
+    public int getDataBitsIndex(int chunkSectionIndex) {
+        return dataBitsIndexes[chunkSectionIndex];
+    }
+
+    public void setDataBitsIndex(int chunkSectionIndex, int dataBitsIndex) {
+        dataBitsIndexes[chunkSectionIndex] = dataBitsIndex;
+    }
+
+    public IBlockState[] getPredefinedBlockData(int chunkSectionIndex) {
+        return predefinedBlockData[chunkSectionIndex];
+    }
+
+    public void setPredefinedBlockData(int chunkSectionIndex, IBlockState[] predefinedBlockData) {
+        this.predefinedBlockData[chunkSectionIndex] = predefinedBlockData;
+    }
+
+    public boolean isWritten(int chunkSectionIndex) {
+        return bitsPerValue[chunkSectionIndex] != 0;
+    }
+}
diff --git a/src/main/java/net/minecraft/entity/item/EntityFallingBlock.java b/src/main/java/net/minecraft/entity/item/EntityFallingBlock.java
index 12aeb02..790a983 100644
--- a/src/main/java/net/minecraft/entity/item/EntityFallingBlock.java
+++ b/src/main/java/net/minecraft/entity/item/EntityFallingBlock.java
@@ -96,6 +96,7 @@ public class EntityFallingBlock extends Entity {
                 if (this.world.getBlockState(blockposition).getBlock() == block
                         && !CraftEventFactory.callEntityChangeBlockEvent(this, blockposition, Blocks.AIR, 0).isCancelled()) {
                     this.world.setBlockToAir(blockposition);
+                    this.world.chunkPacketBlockController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
                 } else if (!this.world.isRemote) {
                     this.setDead();
                     return;
@@ -175,6 +176,7 @@ public class EntityFallingBlock extends Entity {
                                 }
 
                                 this.world.setBlockState(blockposition, this.fallTile, 3);
+                                this.world.chunkPacketBlockController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
 
                                 if (block instanceof BlockFalling) {
                                     ((BlockFalling) block).onEndFalling(this.world, blockposition, this.fallTile, iblockdata);
diff --git a/src/main/java/net/minecraft/network/NetworkManager.java b/src/main/java/net/minecraft/network/NetworkManager.java
index ddda859..c57a348 100644
--- a/src/main/java/net/minecraft/network/NetworkManager.java
+++ b/src/main/java/net/minecraft/network/NetworkManager.java
@@ -23,6 +23,8 @@ import java.util.UUID;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 import javax.annotation.Nullable;
 import javax.crypto.SecretKey;
+
+import net.minecraft.network.play.server.SPacketChunkData;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.CryptManager;
 import net.minecraft.util.ITickable;
@@ -148,8 +150,8 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
     }
 
     public void sendPacket(Packet<?> packetIn) {
-        if (this.isChannelOpen()) {
-            this.flushOutboundQueue();
+        if (this.isChannelOpen() && this.flushOutboundQueue() && !(packetIn instanceof SPacketChunkData && !((SPacketChunkData) packetIn).isReady())) { // Paper - Async-Anti-Xray - Add chunk packets which are not ready or all packets if the queue contains chunk packets which are not ready to the queue and send the packets later in the right order
+            // this.flushOutboundQueue(); // Paper - Async-Anti-Xray - Move to if statement (this.flushOutboundQueue())
             this.dispatchPacket(packetIn, (GenericFutureListener[]) null);
         } else {
             this.readWriteLock.writeLock().lock();
@@ -166,8 +168,8 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
             Packet<?> packetIn,
             GenericFutureListener<? extends Future<? super Void>> listener,
             GenericFutureListener<? extends Future<? super Void>>... listeners) {
-        if (this.isChannelOpen()) {
-            this.flushOutboundQueue();
+        if (this.isChannelOpen() && this.flushOutboundQueue() && !(packetIn instanceof SPacketChunkData && !((SPacketChunkData) packetIn).isReady())) { // Paper - Async-Anti-Xray - Add chunk packets which are not ready or all packets if the queue contains chunk packets which are not ready to the queue and send the packets later in the right order
+            //this.flushOutboundQueue(); // Paper - Async-Anti-Xray - Move to if statement (this.flushOutboundQueue())
             this.dispatchPacket(packetIn, (GenericFutureListener[]) ArrayUtils.add(listeners, 0, listener));
         } else {
             this.readWriteLock.writeLock().lock();
@@ -226,20 +228,36 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
         }
     }
 
-    private void flushOutboundQueue() {
+    // Paper start - Async-Anti-Xray - Stop dispatching further packets and return false if the peeked packet is a chunk packet which is not ready
+    private boolean flushOutboundQueue() { // void -> boolean
         if (this.channel != null && this.channel.isOpen()) {
-            this.readWriteLock.readLock().lock();
+            if (this.outboundPacketsQueue.isEmpty()) { // return if the packet queue is empty so that the write lock by Anti-Xray doesn't affect the vanilla performance at all
+                return true;
+            }
+
+            this.readWriteLock.writeLock().lock(); // readLock -> writeLock (because of race condition between peek and poll)
 
             try {
                 while (!this.outboundPacketsQueue.isEmpty()) {
-                    NetworkManager.InboundHandlerTuplePacketListener networkmanager_queuedpacket = this.outboundPacketsQueue.poll();
-                    this.dispatchPacket(networkmanager_queuedpacket.packet, networkmanager_queuedpacket.futureListeners);
+                    NetworkManager.InboundHandlerTuplePacketListener networkmanager_queuedpacket = this.outboundPacketsQueue.peek(); // poll -> peek
+
+                    if (networkmanager_queuedpacket != null) { // Fix NPE (Spigot bug caused by handleDisconnection())
+                        if (networkmanager_queuedpacket.packet instanceof SPacketChunkData && !((SPacketChunkData) networkmanager_queuedpacket.packet).isReady()) { // Check if the peeked packet is a chunk packet which is not ready
+                            return false; // Return false if the peeked packet is a chunk packet which is not ready
+                        } else {
+                            this.outboundPacketsQueue.poll(); // poll here
+                            this.dispatchPacket(networkmanager_queuedpacket.packet, networkmanager_queuedpacket.futureListeners); // dispatch the packet
+                        }
+                    }
                 }
             } finally {
-                this.readWriteLock.readLock().unlock();
+                this.readWriteLock.writeLock().unlock(); // readLock -> writeLock (because of race condition between peek and poll)
             }
         }
+
+        return true; // Return true if all packets were dispatched
     }
+    // Paper end
 
     public void processReceivedPackets() {
         this.flushOutboundQueue();
diff --git a/src/main/java/net/minecraft/network/play/server/SPacketChunkData.java b/src/main/java/net/minecraft/network/play/server/SPacketChunkData.java
index 092f4e0..f8b5c1f 100644
--- a/src/main/java/net/minecraft/network/play/server/SPacketChunkData.java
+++ b/src/main/java/net/minecraft/network/play/server/SPacketChunkData.java
@@ -1,5 +1,6 @@
 package net.minecraft.network.play.server;
 
+import com.destroystokyo.paper.antixray.SPacketMapChunkInfo; // Paper - Anti-Xray
 import com.google.common.collect.Lists;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
@@ -15,6 +16,8 @@ import net.minecraft.util.math.BlockPos;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.storage.ExtendedBlockStorage;
 
+import javax.annotation.Nullable;
+
 public class SPacketChunkData implements Packet<INetHandlerPlayClient> {
     private int chunkX;
     private int chunkZ;
@@ -22,16 +25,27 @@ public class SPacketChunkData implements Packet<INetHandlerPlayClient> {
     private byte[] buffer;
     private List<NBTTagCompound> tileEntityTags;
     private boolean fullChunk;
+    private volatile boolean ready = false; // Paper - Async-Anti-Xray - Ready flag for the network manager
 
-    public SPacketChunkData() {}
+    public SPacketChunkData() {
+        this.ready = true; // Paper - Async-Anti-Xray - Set the ready flag to true
+    }
 
     public SPacketChunkData(Chunk chunkIn, int changedSectionFilter) {
+        SPacketMapChunkInfo SPacketMapChunkInfo = chunkIn.world.chunkPacketBlockController.getSPacketChunkData(this, chunkIn, changedSectionFilter); // Paper - Anti-Xray - Add chunk packet info
         this.chunkX = chunkIn.x;
         this.chunkZ = chunkIn.z;
         this.fullChunk = changedSectionFilter == 65535;
         boolean var3 = chunkIn.getWorld().provider.hasSkyLight();
         this.buffer = new byte[this.calculateChunkSize(chunkIn, var3, changedSectionFilter)];
-        this.availableSections = this.extractChunkData(new PacketBuffer(this.getWriteBuffer()), chunkIn, var3, changedSectionFilter);
+
+        // Paper start - Anti-Xray - Add chunk packet info
+        if (SPacketMapChunkInfo != null) {
+            SPacketMapChunkInfo.setData(this.buffer);
+        }
+        // Paper end
+
+        this.availableSections = this.extractChunkData(new PacketBuffer(this.getWriteBuffer()), chunkIn, var3, changedSectionFilter, SPacketMapChunkInfo); // Paper - Anti-Xray - Add chunk packet info
         this.tileEntityTags = Lists.<NBTTagCompound>newArrayList();
 
         for (Entry var5 : chunkIn.getTileEntityMap().entrySet()) {
@@ -44,8 +58,20 @@ public class SPacketChunkData implements Packet<INetHandlerPlayClient> {
                 this.tileEntityTags.add(var9);
             }
         }
+
+        chunkIn.world.chunkPacketBlockController.modifyBlocks(this, SPacketMapChunkInfo); // Paper - Anti-Xray - Modify blocks
     }
 
+    // Paper start - Async-Anti-Xray - Getter and Setter for the ready flag
+    public boolean isReady() {
+        return this.ready;
+    }
+
+    public void setReady(boolean ready) {
+        this.ready = ready;
+    }
+    // Paper end
+
     public void readPacketData(PacketBuffer buf) throws IOException {
         this.chunkX = buf.readInt();
         this.chunkZ = buf.readInt();
@@ -92,6 +118,10 @@ public class SPacketChunkData implements Packet<INetHandlerPlayClient> {
     }
 
     public int extractChunkData(PacketBuffer buf, Chunk chunkIn, boolean writeSkylight, int changedSectionFilter) {
+        return extractChunkData(buf, chunkIn, writeSkylight, changedSectionFilter, null);
+    }
+
+    public int extractChunkData(PacketBuffer buf, Chunk chunkIn, boolean writeSkylight, int changedSectionFilter, @Nullable SPacketMapChunkInfo SPacketMapChunkInfo) { // Paper - Anti-Xray - Add chunk packet info
         int var5 = 0;
         ExtendedBlockStorage[] var6 = chunkIn.getBlockStorageArray();
         int var7 = 0;
@@ -101,7 +131,7 @@ public class SPacketChunkData implements Packet<INetHandlerPlayClient> {
 
             if (var9 != Chunk.NULL_BLOCK_STORAGE && (!this.isFullChunk() || !var9.isEmpty()) && (changedSectionFilter & 1 << var7) != 0) {
                 var5 |= 1 << var7;
-                var9.getData().write(buf);
+                var9.getData().write(buf, SPacketMapChunkInfo, var7);
                 buf.writeBytes(var9.getBlockLight().getData());
 
                 if (writeSkylight) {
diff --git a/src/main/java/net/minecraft/server/management/PlayerChunkMapEntry.java b/src/main/java/net/minecraft/server/management/PlayerChunkMapEntry.java
index 8186cfd..318b693 100644
--- a/src/main/java/net/minecraft/server/management/PlayerChunkMapEntry.java
+++ b/src/main/java/net/minecraft/server/management/PlayerChunkMapEntry.java
@@ -136,6 +136,8 @@ public class PlayerChunkMapEntry {
             return false;
         } else if (!this.chunk.isPopulated()) {
             return false;
+        } else if (!this.chunk.world.chunkPacketBlockController.onChunkPacketCreate(this.chunk, '\uffff', false)) { // Paper - Anti-Xray - Load nearby chunks if necessary
+            return false; // Paper - Anti-Xray - Wait and try again later
         } else {
             this.changes = 0;
             this.changedSectionFilter = 0;
@@ -153,6 +155,7 @@ public class PlayerChunkMapEntry {
 
     public void sendToPlayer(EntityPlayerMP player) {
         if (this.sentToPlayers) {
+            this.chunk.world.chunkPacketBlockController.onChunkPacketCreate(this.chunk, '\uffff', true); // Paper - Anti-Xray - Load nearby chunks if necessary
             player.connection.sendPacket(new SPacketChunkData(this.chunk, 65535));
             this.playerChunkMap.getWorldServer().getEntityTracker().sendLeashedEntitiesInChunk(player, this.chunk);
         }
@@ -211,6 +214,7 @@ public class PlayerChunkMapEntry {
                     this.sendBlockEntity(this.playerChunkMap.getWorldServer().getTileEntity(blockposition));
                 }
             } else if (this.changes == 64) {
+                this.chunk.world.chunkPacketBlockController.onChunkPacketCreate(this.chunk, this.changedSectionFilter, true); // Paper - Anti-Xray - Load nearby chunks if necessary
                 this.sendPacket(new SPacketChunkData(this.chunk, this.changedSectionFilter));
             } else {
                 this.sendPacket(new SPacketMultiBlockChange(this.changes, this.changedBlocks, this.chunk));
diff --git a/src/main/java/net/minecraft/server/management/PlayerInteractionManager.java b/src/main/java/net/minecraft/server/management/PlayerInteractionManager.java
index 8b2f882..1581364 100644
--- a/src/main/java/net/minecraft/server/management/PlayerInteractionManager.java
+++ b/src/main/java/net/minecraft/server/management/PlayerInteractionManager.java
@@ -230,6 +230,8 @@ public class PlayerInteractionManager {
                 }
             }
         }
+
+        this.world.chunkPacketBlockController.updateNearbyBlocks(this.world, pos); // Paper - Anti-Xray
     }
 
     public void blockRemoving(BlockPos pos) {
diff --git a/src/main/java/net/minecraft/world/Explosion.java b/src/main/java/net/minecraft/world/Explosion.java
index c9b8c29..012d561 100644
--- a/src/main/java/net/minecraft/world/Explosion.java
+++ b/src/main/java/net/minecraft/world/Explosion.java
@@ -244,6 +244,7 @@ public class Explosion {
             for (BlockPos blockposition : this.affectedBlockPositions) {
                 IBlockState iblockdata = this.world.getBlockState(blockposition);
                 net.minecraft.block.Block block = iblockdata.getBlock();
+                this.world.chunkPacketBlockController.updateNearbyBlocks(this.world, blockposition); // Paper - Anti-Xray
 
                 if (spawnParticles) {
                     double d0 = (double) ((float) blockposition.getX() + this.world.rand.nextFloat());
diff --git a/src/main/java/net/minecraft/world/World.java b/src/main/java/net/minecraft/world/World.java
index 8a8efdf..82e3c8e 100644
--- a/src/main/java/net/minecraft/world/World.java
+++ b/src/main/java/net/minecraft/world/World.java
@@ -1,5 +1,7 @@
 package net.minecraft.world;
 
+import com.destroystokyo.paper.antixray.ChunkPacketBlockController; // Anti-Xray
+import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray; // Anti-Xray
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerInternalException;
 import com.google.common.base.Function;
@@ -163,6 +165,7 @@ public abstract class World implements IBlockAccess {
     private int tickPosition;
     public final SpigotWorldConfig spigotConfig;
     public final com.destroystokyo.paper.PaperWorldConfig paperConfig; // Paper
+    public final ChunkPacketBlockController chunkPacketBlockController; // Paper - Anti-Xray
     public final co.aikar.timings.WorldTimingsHandler timings; // Paper
     private boolean guardEntityList;
     public static boolean haveWeSilencedAPhysicsCrash;
@@ -195,6 +198,7 @@ public abstract class World implements IBlockAccess {
             Environment p_i71_7_) {
         this.spigotConfig = new SpigotWorldConfig(p_i71_2_.getWorldName());
         this.paperConfig = new com.destroystokyo.paper.PaperWorldConfig(p_i71_2_.getWorldName(), this.spigotConfig); // Paper
+        this.chunkPacketBlockController = this.paperConfig.antiXray ? new ChunkPacketBlockControllerAntiXray(this.paperConfig) : ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
         this.generator = p_i71_6_;
         this.world = new CraftWorld((WorldServer) this, p_i71_6_, p_i71_7_);
         this.ticksPerAnimalSpawns = (long) this.getServer().getTicksPerAnimalSpawns();
@@ -597,6 +601,8 @@ public abstract class World implements IBlockAccess {
         if (skipSide != EnumFacing.SOUTH) {
             this.neighborChanged(pos.south(), blockType, pos);
         }
+
+        this.chunkPacketBlockController.updateNearbyBlocks(this, pos); // Paper - Anti-Xray
     }
 
     public void neighborChanged(BlockPos pos, final Block blockIn, BlockPos fromPos) {
diff --git a/src/main/java/net/minecraft/world/chunk/BlockStateContainer.java b/src/main/java/net/minecraft/world/chunk/BlockStateContainer.java
index 5201758..f1760b6 100644
--- a/src/main/java/net/minecraft/world/chunk/BlockStateContainer.java
+++ b/src/main/java/net/minecraft/world/chunk/BlockStateContainer.java
@@ -1,6 +1,7 @@
 package net.minecraft.world.chunk;
 
 import javax.annotation.Nullable;
+import com.destroystokyo.paper.antixray.SPacketMapChunkInfo; // Paper - Anti-Xray
 import net.minecraft.block.Block;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.init.Blocks;
@@ -14,11 +15,38 @@ public class BlockStateContainer implements IBlockStatePaletteResizer {
     protected BitArray storage;
     protected IBlockStatePalette palette;
     private int bits;
+    private final IBlockState[] predefinedBlockData; // Paper - Anti-Xray - Add predefined block data
 
+    // Paper start - Anti-Xray - Support default constructor
     public BlockStateContainer() {
-        this.setBits(4);
+        this(null);
     }
 
+    // Anti-Xray - Add predefined block data
+    public BlockStateContainer(@Nullable IBlockState[] predefinedBlockData) {
+        this.predefinedBlockData = predefinedBlockData;
+
+        if (predefinedBlockData == null) {
+            // Default constructor
+            this.setBits(4);
+        } else {
+            // Count the bits of the maximum array index to initialize a data palette with enough space from the beginning
+            // The length of the array is used because air is also added to the data palette from the beginning
+            // Start with at least 4
+            int maxIndex = predefinedBlockData.length >> 4;
+            int bitCount = 4;
+
+            while (maxIndex != 0) {
+                maxIndex >>= 1;
+                bitCount++;
+            }
+
+            // Initialize with at least 15 free indixes
+            this.setBits((1 << bitCount) - predefinedBlockData.length < 16 ? bitCount + 1 : bitCount);
+        }
+    }
+    // Paper end
+
     private static int getIndex(int x, int y, int z) {
         return y << 8 | z << 4 | x;
     }
@@ -38,6 +66,15 @@ public class BlockStateContainer implements IBlockStatePaletteResizer {
             }
 
             this.palette.idFor(AIR_BLOCK_STATE);
+
+            // Paper start - Anti-Xray - Add predefined block data
+            if (this.predefinedBlockData != null) {
+                for (int j = 0; j < this.predefinedBlockData.length; j++) {
+                    this.palette.idFor(this.predefinedBlockData[j]);
+                }
+            }
+            // Paper end
+
             this.storage = new BitArray(this.bits, 4096);
         }
     }
@@ -76,9 +113,25 @@ public class BlockStateContainer implements IBlockStatePaletteResizer {
         return iblockdata == null ? AIR_BLOCK_STATE : iblockdata;
     }
 
+    // Paper start - Anti-Xray - Support default method
     public void write(PacketBuffer buf) {
+        this.write(buf, null, 0);
+    }
+    // Paper end
+
+    public void write(PacketBuffer buf, @Nullable SPacketMapChunkInfo SPacketMapChunkInfo, int chunkSectionIndex) { // Paper - Anti-Xray - Add chunk packet info
         buf.writeByte(this.bits);
         this.palette.write(buf);
+
+        // Paper start - Anti-Xray - Add chunk packet info
+        if (SPacketMapChunkInfo != null) {
+            SPacketMapChunkInfo.setBitsPerValue(chunkSectionIndex, this.bits);
+            SPacketMapChunkInfo.setBlockStatePalette(chunkSectionIndex, this.palette);
+            SPacketMapChunkInfo.setDataBitsIndex(chunkSectionIndex, buf.writerIndex() + PacketBuffer.getVarIntSize(this.storage.getBackingLongArray().length));
+            SPacketMapChunkInfo.setPredefinedBlockData(chunkSectionIndex, this.predefinedBlockData);
+        }
+        // Paper end
+
         buf.writeLongArray(this.storage.getBackingLongArray());
     }
 
diff --git a/src/main/java/net/minecraft/world/chunk/Chunk.java b/src/main/java/net/minecraft/world/chunk/Chunk.java
index 83b5abe..4756884 100644
--- a/src/main/java/net/minecraft/world/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/chunk/Chunk.java
@@ -161,7 +161,7 @@ public class Chunk {
                         int j1 = i1 >> 4;
 
                         if (this.storageArrays[j1] == NULL_BLOCK_STORAGE) {
-                            this.storageArrays[j1] = new ExtendedBlockStorage(j1 << 4, flag1);
+                            this.storageArrays[j1] = new ExtendedBlockStorage(j1 << 4, flag1, world.chunkPacketBlockController.getPredefinedBlockData(this, j1)); // Paper - Anti-Xray - Add predefined block data
                         }
 
                         this.storageArrays[j1].set(k, i1 & 15, l, iblockdata);
@@ -513,7 +513,7 @@ public class Chunk {
                     return null;
                 }
 
-                chunksection = new ExtendedBlockStorage(j >> 4 << 4, this.world.provider.hasSkyLight());
+                chunksection = new ExtendedBlockStorage(j >> 4 << 4, this.world.provider.hasSkyLight(), this.world.chunkPacketBlockController.getPredefinedBlockData(this, j >> 4)); // Paper - Anti-Xray - Add predefined block data
                 this.storageArrays[j >> 4] = chunksection;
                 flag = j >= i1;
             }
@@ -602,7 +602,7 @@ public class Chunk {
         ExtendedBlockStorage chunksection = this.storageArrays[k >> 4];
 
         if (chunksection == NULL_BLOCK_STORAGE) {
-            chunksection = new ExtendedBlockStorage(k >> 4 << 4, this.world.provider.hasSkyLight());
+            chunksection = new ExtendedBlockStorage(k >> 4 << 4, this.world.provider.hasSkyLight(), this.world.chunkPacketBlockController.getPredefinedBlockData(this, k >> 4)); // Paper - Anti-Xray - Add predefined block data
             this.storageArrays[k >> 4] = chunksection;
             this.generateSkylightMap();
         }
diff --git a/src/main/java/net/minecraft/world/chunk/storage/AnvilChunkLoader.java b/src/main/java/net/minecraft/world/chunk/storage/AnvilChunkLoader.java
index 9bbd780..8a3e721 100644
--- a/src/main/java/net/minecraft/world/chunk/storage/AnvilChunkLoader.java
+++ b/src/main/java/net/minecraft/world/chunk/storage/AnvilChunkLoader.java
@@ -386,7 +386,7 @@ public class AnvilChunkLoader implements IChunkLoader, IThreadedFileIO {
         for (int k = 0; k < nbttaglist.tagCount(); ++k) {
             NBTTagCompound nbttagcompound1 = nbttaglist.getCompoundTagAt(k);
             byte b0 = nbttagcompound1.getByte("Y");
-            ExtendedBlockStorage chunksection = new ExtendedBlockStorage(b0 << 4, flag1);
+            ExtendedBlockStorage chunksection = new ExtendedBlockStorage(b0 << 4, flag1, worldIn.chunkPacketBlockController.getPredefinedBlockData(chunk, b0)); // Paper - Anti-Xray - Add predefined block data
             byte[] abyte = nbttagcompound1.getByteArray("Blocks");
             NibbleArray nibblearray = new NibbleArray(nbttagcompound1.getByteArray("Data"));
             NibbleArray nibblearray1 = nbttagcompound1.hasKey("Add", 7) ? new NibbleArray(nbttagcompound1.getByteArray("Add")) : null;
diff --git a/src/main/java/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java b/src/main/java/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java
index a1b575d..ae152f0 100644
--- a/src/main/java/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java
+++ b/src/main/java/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java
@@ -6,6 +6,8 @@ import net.minecraft.init.Blocks;
 import net.minecraft.world.chunk.BlockStateContainer;
 import net.minecraft.world.chunk.NibbleArray;
 
+import javax.annotation.Nullable; // Paper
+
 public class ExtendedBlockStorage {
     private final int yBase;
     private int blockRefCount;
@@ -14,9 +16,15 @@ public class ExtendedBlockStorage {
     private NibbleArray blockLight;
     private NibbleArray skyLight;
 
+    // Paper start - Anti-Xray - Support default constructor
     public ExtendedBlockStorage(int y, boolean storeSkylight) {
+        this(y,storeSkylight, (IBlockState[]) null);
+    }
+    // Paper end
+
+    public ExtendedBlockStorage(int y, boolean storeSkylight, @Nullable IBlockState[] predefinedBlockData) { // Paper - Anti-Xray - Add predefined block data
         this.yBase = y;
-        this.data = new BlockStateContainer();
+        this.data = new BlockStateContainer(predefinedBlockData); // Paper - Anti-Xray - Add predefined block data
         this.blockLight = new NibbleArray();
 
         if (storeSkylight) {
@@ -24,9 +32,15 @@ public class ExtendedBlockStorage {
         }
     }
 
+    // Paper start - Anti-Xray - Support default constructor
     public ExtendedBlockStorage(int p_i5_1_, boolean p_i5_2_, char[] p_i5_3_) {
+        this(p_i5_1_, p_i5_2_, p_i5_3_, null);
+    }
+    // Paper end
+
+    public ExtendedBlockStorage(int p_i5_1_, boolean p_i5_2_, char[] p_i5_3_, @Nullable IBlockState[] predefinedBlockData) { // Paper - Anti-Xray - Add predefined block data
         this.yBase = p_i5_1_;
-        this.data = new BlockStateContainer();
+        this.data = new BlockStateContainer(predefinedBlockData); // Paper - Anti-Xray - Add predefined block data
 
         for (int i = 0; i < p_i5_3_.length; ++i) {
             int xx = i & 15;
diff --git a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
index c7e7a5d..95d6bc8 100644
--- a/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
+++ b/src/main/java/org/bukkit/craftbukkit/generator/CustomChunkGenerator.java
@@ -57,7 +57,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
                     }
 
                     if (emptyTest != 0) {
-                        csect[sec] = new ExtendedBlockStorage(sec << 4, true, section);
+                        csect[sec] = new ExtendedBlockStorage(sec << 4, true, section, this.world.chunkPacketBlockController.getPredefinedBlockData(chunk, sec)); // Paper - Anti-Xray - Add predefined block data
                     }
                 }
             }
@@ -79,7 +79,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
                             secBlkID[i] = (char) Block.BLOCK_STATE_IDS.get(b.getDefaultState());
                         }
 
-                        csect[sec] = new ExtendedBlockStorage(sec << 4, true, secBlkID);
+                        csect[sec] = new ExtendedBlockStorage(sec << 4, true, secBlkID, this.world.chunkPacketBlockController.getPredefinedBlockData(chunk, sec)); // Paper - Anti-Xray - Add predefined block data
                     }
                 }
             } else {
@@ -99,7 +99,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
                                 secBlkID[i] = (char) Block.BLOCK_STATE_IDS.get(b.getDefaultState());
                             }
 
-                            csect[sec] = new ExtendedBlockStorage(sec << 4, true, secBlkID);
+                            csect[sec] = new ExtendedBlockStorage(sec << 4, true, secBlkID, this.world.chunkPacketBlockController.getPredefinedBlockData(chunk, sec)); // Paper - Anti-Xray - Add predefined block data
                         }
                     }
                 } else {
@@ -135,7 +135,7 @@ public class CustomChunkGenerator extends InternalChunkGenerator {
                         }
 
                         if (csbytes != null) {
-                            ExtendedBlockStorage cs = csect[sec] = new ExtendedBlockStorage(sec << 4, true, csbytes);
+                            ExtendedBlockStorage cs = csect[sec] = new ExtendedBlockStorage(sec << 4, true, csbytes, this.world.chunkPacketBlockController.getPredefinedBlockData(chunk, sec)); // Paper - Anti-Xray - Add predefined block data
                             cs.recalculateRefCounts();
                         }
                     }
-- 
2.18.0

