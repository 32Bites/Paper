From 1467bf5d2a763c56843e2aa73bb2c10a13201f7e Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Mon, 9 Oct 2017 18:42:48 -0400
Subject: [PATCH] Ensure Chunks never ever load async

Safely pushes the operation to main thread, then back to the posting thread

diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
index 53c9945..638b79b 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOExecutor.java
@@ -1,5 +1,6 @@
 package org.bukkit.craftbukkit.chunkio;
 
+import com.destroystokyo.paper.util.MCUtil;
 import net.minecraft.world.World;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.storage.AnvilChunkLoader;
@@ -13,7 +14,7 @@ public class ChunkIOExecutor {
             new AsynchronousExecutor<QueuedChunk, Chunk, Runnable, RuntimeException>(new ChunkIOProvider(), 1);
 
     public static Chunk syncChunkLoad(World world, AnvilChunkLoader loader, ChunkProviderServer provider, int x, int z) {
-        return instance.getSkipQueue(new QueuedChunk(x, z, loader, world, provider));
+        return MCUtil.ensureMain("Async Chunk Load", () -> instance.getSkipQueue(new QueuedChunk(x, z, loader, world, provider))); // Paper
     }
 
     public static void queueChunkLoad(World world, AnvilChunkLoader loader, ChunkProviderServer provider, int x, int z, Runnable runnable) {
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
index 89948dc..48268b4 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
@@ -30,7 +30,8 @@ class ChunkIOProvider implements AsynchronousExecutor.CallBackProvider<QueuedChu
     }
 
     public void callStage2(QueuedChunk queuedChunk, Chunk chunk) throws RuntimeException {
-        if (chunk == null) {
+        if (chunk == null || queuedChunk.provider.id2ChunkMap.containsKey(ChunkPos.asLong(queuedChunk.x, queuedChunk.z))) { // Paper - also call original if it was already loaded
+            // If the chunk loading failed (or was already loaded for some reason) just do it synchronously (may generate)
             queuedChunk.provider.originalGetChunkAt(queuedChunk.x, queuedChunk.z);
         } else {
             try (Timing ignored = queuedChunk.provider.world.timings.chunkIOStage2.startTimingIfSync()) { // Paper
-- 
2.18.0

