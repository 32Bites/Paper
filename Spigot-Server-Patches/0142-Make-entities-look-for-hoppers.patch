From 7082a99f849ec7e6cb0b0fac88a9e214ae8369e6 Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Mon, 9 Oct 2017 19:35:54 -0400
Subject: [PATCH] Make entities look for hoppers

Every tick hoppers try and find an block-inventory to extract from.
If no tile entity is above the hopper (which there often isn't) it will do a bounding box search for minecart chests and minecart hoppers.
If it can't find an inventory, it will then look for a dropped item, which is another bounding box search.
This patch eliminates that expensive check by having dropped items and minecart hoppers/chests look for hoppers instead.
Hoppers are tile entities meaning you can do a simple tile entity lookup to find the nearest hopper in range.
Pushing out of hoppers causes a bouding box lookup, which this patch replaces with a tile entity lookup.

This patch may causes a decrease in the performance of dropped items, which is why it can be disabled in the configuration.

diff --git a/src/main/java/com/destroystokyo/paper/HopperPusher.java b/src/main/java/com/destroystokyo/paper/HopperPusher.java
new file mode 100644
index 0000000..f9d30db
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/HopperPusher.java
@@ -0,0 +1,60 @@
+package com.destroystokyo.paper;
+
+
+import com.destroystokyo.paper.util.MCUtil;
+import net.minecraft.tileentity.TileEntityHopper;
+import net.minecraft.util.math.AxisAlignedBB;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.world.World;
+
+public interface HopperPusher {
+
+    default TileEntityHopper findHopper() {
+        BlockPos pos = new BlockPos(getX(), getY(), getZ());
+        int startX = pos.getX() - 1;
+        int endX = pos.getX() + 1;
+        int startY = Math.max(0, pos.getY() - 1);
+        int endY = Math.min(255, pos.getY() + 1);
+        int startZ = pos.getZ() - 1;
+        int endZ = pos.getZ() + 1;
+        BlockPos.PooledMutableBlockPos adjacentPos = BlockPos.PooledMutableBlockPos.retain();
+        for (int x = startX; x <= endX; x++) {
+            for (int y = startY; y <= endY; y++) {
+                for (int z = startZ; z <= endZ; z++) {
+                    adjacentPos.setPos(x, y, z);
+                    TileEntityHopper hopper = MCUtil.getHopper(getEntityWorldPaper(), adjacentPos);
+                    if (hopper == null) continue; // Avoid playing with the bounding boxes, if at all possible
+                    AxisAlignedBB hopperBoundingBox = hopper.getHopperLookupBoundingBox();
+                    /*
+                     * Check if the entity's bounding box intersects with the hopper's lookup box.
+                     * This operation doesn't work both ways!
+                     * Make sure you check if the entity's box intersects the hopper's box, not vice versa!
+                     */
+                    if (this.getEntityBoundingBox().intersects(hopperBoundingBox)) {
+                        return hopper;
+                    }
+                }
+            }
+        }
+        adjacentPos.release();
+        return null;
+    }
+
+    boolean acceptItem(TileEntityHopper hopper);
+
+    default boolean tryPutInHopper() {
+        if (!getEntityWorldPaper().paperConfig.isHopperPushBased) return false;
+        TileEntityHopper hopper = findHopper();
+        return hopper != null && hopper.canAcceptItems() && acceptItem(hopper);
+    }
+
+    AxisAlignedBB getEntityBoundingBox();
+
+    World getEntityWorldPaper();
+
+    double getX();
+
+    double getY();
+
+    double getZ();
+}
diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 4cf01a9..d9b2031 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -335,4 +335,9 @@ public class PaperWorldConfig {
     private void altFallingBlockOnGround() {
         altFallingBlockOnGround = getBoolean("use-alternate-fallingblock-onGround-detection", false);
     }
+
+    public boolean isHopperPushBased;
+    private void isHopperPushBased() {
+        isHopperPushBased = getBoolean("hopper.push-based", false);
+    }
 }
diff --git a/src/main/java/net/minecraft/entity/Entity.java b/src/main/java/net/minecraft/entity/Entity.java
index fa06c44..d6b805c 100644
--- a/src/main/java/net/minecraft/entity/Entity.java
+++ b/src/main/java/net/minecraft/entity/Entity.java
@@ -136,6 +136,19 @@ public abstract class Entity implements ICommandSender {
     public double posX;
     public double posY;
     public double posZ;
+    // Paper start - getters to implement HopperPusher
+    public double getX() {
+        return posX;
+    }
+
+    public double getY() {
+        return posY;
+    }
+
+    public double getZ() {
+        return posZ;
+    }
+    // Paper end
     public double motionX;
     public double motionY;
     public double motionZ;
@@ -2654,6 +2667,8 @@ public abstract class Entity implements ICommandSender {
         return this.world;
     }
 
+    public World getEntityWorldPaper() { return getEntityWorld(); } // Paper - implement for HopperPusher
+
     public Entity getCommandSenderEntity() {
         return this;
     }
diff --git a/src/main/java/net/minecraft/entity/item/EntityItem.java b/src/main/java/net/minecraft/entity/item/EntityItem.java
index c190b2a..739ae0b 100644
--- a/src/main/java/net/minecraft/entity/item/EntityItem.java
+++ b/src/main/java/net/minecraft/entity/item/EntityItem.java
@@ -1,6 +1,8 @@
 package net.minecraft.entity.item;
 
 import javax.annotation.Nullable;
+
+import com.destroystokyo.paper.HopperPusher;
 import net.minecraft.block.material.Material;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.MoverType;
@@ -15,6 +17,7 @@ import net.minecraft.network.datasync.DataSerializers;
 import net.minecraft.network.datasync.EntityDataManager;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.stats.StatList;
+import net.minecraft.tileentity.TileEntityHopper;
 import net.minecraft.util.DamageSource;
 import net.minecraft.util.datafix.DataFixer;
 import net.minecraft.util.datafix.FixTypes;
@@ -30,7 +33,14 @@ import org.bukkit.entity.Player;
 import org.bukkit.event.entity.EntityPickupItemEvent;
 import org.bukkit.event.player.PlayerPickupItemEvent;
 
-public class EntityItem extends Entity {
+// Paper start - implement HopperPusher
+public class EntityItem extends Entity implements HopperPusher {
+    @Override
+    public boolean acceptItem(TileEntityHopper hopper) {
+        //noinspection ConstantConditions - this is fine
+        return TileEntityHopper.putDropInInventoryAllSlots(null, hopper, this);
+    }
+// Paper end
     private static final Logger LOGGER = LogManager.getLogger();
     private static final DataParameter<ItemStack> ITEM =
             EntityDataManager.<ItemStack>createKey(EntityItem.class, DataSerializers.ITEM_STACK);
@@ -82,6 +92,7 @@ public class EntityItem extends Entity {
             this.setDead();
         } else {
             super.onUpdate();
+            if (tryPutInHopper()) return; // Paper
             int elapsedTicks = MinecraftServer.currentTick - this.lastTick;
 
             if (this.pickupDelay != 32767) {
@@ -179,6 +190,7 @@ public class EntityItem extends Entity {
     }
 
     public void inactiveTick() {
+        if (tryPutInHopper()) return; // Paper
         int elapsedTicks = MinecraftServer.currentTick - this.lastTick;
 
         if (this.pickupDelay != 32767) {
diff --git a/src/main/java/net/minecraft/entity/item/EntityMinecartContainer.java b/src/main/java/net/minecraft/entity/item/EntityMinecartContainer.java
index 316a3b4..785c332 100644
--- a/src/main/java/net/minecraft/entity/item/EntityMinecartContainer.java
+++ b/src/main/java/net/minecraft/entity/item/EntityMinecartContainer.java
@@ -1,5 +1,6 @@
 package net.minecraft.entity.item;
 
+import com.destroystokyo.paper.HopperPusher; // Paper
 import com.destroystokyo.paper.loottable.CraftLootableInventoryData; // Paper
 import com.destroystokyo.paper.loottable.CraftLootableInventory; // Paper
 import com.destroystokyo.paper.loottable.LootableInventory; // Paper
@@ -13,6 +14,7 @@ import net.minecraft.inventory.InventoryHelper;
 import net.minecraft.inventory.ItemStackHelper;
 import net.minecraft.item.ItemStack;
 import net.minecraft.nbt.NBTTagCompound;
+import net.minecraft.tileentity.TileEntityHopper;
 import net.minecraft.util.DamageSource;
 import net.minecraft.util.EnumHand;
 import net.minecraft.util.NonNullList;
@@ -33,7 +35,26 @@ import org.bukkit.entity.Entity;
 import org.bukkit.entity.HumanEntity;
 import org.bukkit.inventory.InventoryHolder;
 
-public abstract class EntityMinecartContainer extends EntityMinecart implements ILockableContainer, ILootContainer, CraftLootableInventory { // Paper
+// Paper start - push into hoppers
+public abstract class EntityMinecartContainer extends EntityMinecart implements ILockableContainer, ILootContainer, CraftLootableInventory, HopperPusher { // Paper
+    @Override
+    public boolean acceptItem(TileEntityHopper hopper) {
+        return TileEntityHopper.pullItems(hopper, this);
+    }
+
+    @Override
+    public void onUpdate() {
+        super.onUpdate();
+        tryPutInHopper();
+    }
+
+    @Override
+    public void inactiveTick() {
+        super.inactiveTick();
+        tryPutInHopper();
+    }
+    // Paper end
+
     private NonNullList<ItemStack> minecartContainerItems = NonNullList.<ItemStack>withSize(this.getSizeInventory(), ItemStack.EMPTY);
     private boolean dropContentsWhenDead = true;
     private ResourceLocation lootTable;
diff --git a/src/main/java/net/minecraft/tileentity/TileEntityHopper.java b/src/main/java/net/minecraft/tileentity/TileEntityHopper.java
index e404d7c..9da7ede 100644
--- a/src/main/java/net/minecraft/tileentity/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/tileentity/TileEntityHopper.java
@@ -144,6 +144,7 @@ public class TileEntityHopper extends TileEntityLockableLoot implements IHopper,
     }
 
     private boolean updateHopper() {
+        mayAcceptItems = false; // Paper - at the beginning of a tick, assume we can't accept items
         if (this.world != null && !this.world.isRemote) {
             if (!this.isOnTransferCooldown() && BlockHopper.isEnabled(this.getBlockMetadata())) {
                 boolean flag = false;
@@ -153,6 +154,7 @@ public class TileEntityHopper extends TileEntityLockableLoot implements IHopper,
                 }
 
                 if (!this.isFull()) {
+                    mayAcceptItems = true; // Paper - flag this hopper to be able to accept items
                     flag = pullItems(this) || flag;
                 }
 
@@ -169,6 +171,14 @@ public class TileEntityHopper extends TileEntityLockableLoot implements IHopper,
         }
     }
 
+    // Paper start
+    private boolean mayAcceptItems = false;
+
+    public boolean canAcceptItems() {
+        return mayAcceptItems;
+    }
+    // Paper end
+
     private boolean isInventoryEmpty() {
         for (ItemStack itemstack : this.inventory) {
             if (!itemstack.isEmpty()) {
@@ -303,9 +313,15 @@ public class TileEntityHopper extends TileEntityLockableLoot implements IHopper,
         return true;
     }
 
+    // Paper start - split methods, and only do entity lookup if in pull mode
     public static boolean pullItems(IHopper hopper) {
-        IInventory iinventory = getSourceInventory(hopper);
+        IInventory iinventory = getSourceInventory(hopper, !(hopper instanceof TileEntityHopper) || !hopper.getWorld().paperConfig.isHopperPushBased);
 
+        return pullItems(hopper, iinventory);
+    }
+
+    public static boolean pullItems(IHopper hopper, IInventory iinventory) {
+        // Paper end
         if (iinventory != null) {
             EnumFacing enumdirection = EnumFacing.DOWN;
 
@@ -331,8 +347,8 @@ public class TileEntityHopper extends TileEntityLockableLoot implements IHopper,
                     }
                 }
             }
-        } else {
-            for (EntityItem entityitem : getCaptureItems(hopper.getWorld(), hopper.getXPos(), hopper.getYPos(), hopper.getZPos())) {
+        } else if (!hopper.getWorld().paperConfig.isHopperPushBased || !(hopper instanceof TileEntityHopper)) { // Paper - only search for entities in 'pull mode'
+            for (EntityItem entityitem : getCaptureItems(hopper.getWorld(), hopper.getXPos(), hopper.getYPos(), hopper.getZPos())) {  // Change getHopperLookupBoundingBox() if this ever changes
                 if (putDropInInventoryAllSlots((IInventory) null, hopper, entityitem)) {
                     return true;
                 }
@@ -503,26 +519,51 @@ public class TileEntityHopper extends TileEntityLockableLoot implements IHopper,
 
     private IInventory getInventoryForHopperTransfer() {
         EnumFacing enumdirection = BlockHopper.getFacing(this.getBlockMetadata());
+        // Paper start - don't search for entities in push mode
         return getInventoryAtPosition(
                 this.getWorld(),
                 this.getXPos() + (double) enumdirection.getFrontOffsetX(),
                 this.getYPos() + (double) enumdirection.getFrontOffsetY(),
-                this.getZPos() + (double) enumdirection.getFrontOffsetZ());
+                this.getZPos() + (double) enumdirection.getFrontOffsetZ(),
+                !world.paperConfig.isHopperPushBased);
+        // Paper end
     }
 
     public static IInventory getSourceInventory(IHopper hopper) {
-        return getInventoryAtPosition(hopper.getWorld(), hopper.getXPos(), hopper.getYPos() + 1.0D, hopper.getZPos());
+        return getSourceInventory(hopper, true);
+    }
+
+    public static IInventory getSourceInventory(IHopper hopper, boolean searchForEntities) {
+        return getInventoryAtPosition(hopper.getWorld(), hopper.getXPos(), hopper.getYPos() + 1.0D, hopper.getZPos(), searchForEntities);
     }
 
     public static List<EntityItem> getCaptureItems(World worldIn, double p_184292_1_, double p_184292_3_, double p_184292_5_) {
         return worldIn.<EntityItem>getEntitiesWithinAABB(
                 EntityItem.class,
                 new AxisAlignedBB(
+                        // Change getHopperLookupBoundingBox(double, double, double) if the bounding box calculation is ever changed
                         p_184292_1_ - 0.5D, p_184292_3_, p_184292_5_ - 0.5D, p_184292_1_ + 0.5D, p_184292_3_ + 1.5D, p_184292_5_ + 0.5D),
                 EntitySelectors.IS_ALIVE);
     }
 
+    // Paper start
+    public AxisAlignedBB getHopperLookupBoundingBox() {
+        return getHopperLookupBoundingBox(this.getXPos(), this.getYPos(), this.getZPos());
+    }
+
+    private static AxisAlignedBB getHopperLookupBoundingBox(double d0, double d1, double d2) {
+        // Change this if a(World, double, double, double) above ever changes
+        return new AxisAlignedBB(d0 - 0.5D, d1, d2 - 0.5D, d0 + 0.5D, d1 + 1.5D, d2 + 0.5D);
+    }
+    // Paper end
+
+    // Paper start - add option to searchForEntities
     public static IInventory getInventoryAtPosition(World worldIn, double x, double y, double z) {
+        return getInventoryAtPosition(worldIn, x, y, z, true);
+    }
+
+    public static IInventory getInventoryAtPosition(World worldIn, double x, double y, double z, boolean searchForEntities) {
+        // Paper end
         Object object = null;
         int i = MathHelper.floor(x);
         int j = MathHelper.floor(y);
@@ -546,7 +587,7 @@ public class TileEntityHopper extends TileEntityLockableLoot implements IHopper,
                 }
             }
 
-            if (object == null) {
+            if (object == null && searchForEntities) { // Paper - only if searchForEntities
                 List list =
                         worldIn.getEntitiesInAABBexcluding(
                                 (Entity) null,
-- 
2.18.0

