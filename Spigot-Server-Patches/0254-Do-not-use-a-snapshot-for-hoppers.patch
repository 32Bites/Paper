From 8e9dd17ba158ac826c4c427e73ce00bb5decc416 Mon Sep 17 00:00:00 2001
From: Shane Freeder <theboyetronic@gmail.com>
Date: Thu, 4 Jan 2018 20:33:52 -0600
Subject: [PATCH] Do not use a snapshot for hoppers

In 1.12, Spigot improved their blockstate implementation to take a full
copy of the TE, this allows for a much better snapshot in that it will
actually retain all of the TE's state, it is a much more expensive
implementation. This is also implicated with their backwards compat
for inventories meaning that accessing of a snapshots inventory of a
placed block will actually access the inventory of the live TE, making
creation of a snapshot redundant if the only intent is to interact with
the TEs inventory.

Hoppers are a horrible hit, every attempt to transfer an ItemStack will
result in two TileEntity state snapshots, with two hoppers and a double chest
ontop, I managed to log 380 cases per second where a snapshot would have been
taken in cases where the snapshot is redundant.

diff --git a/src/main/java/net/minecraft/tileentity/TileEntityHopper.java b/src/main/java/net/minecraft/tileentity/TileEntityHopper.java
index 9da7ede..900487e 100644
--- a/src/main/java/net/minecraft/tileentity/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/tileentity/TileEntityHopper.java
@@ -223,12 +223,16 @@ public class TileEntityHopper extends TileEntityLockableLoot implements IHopper,
 
                         if (iinventory instanceof InventoryLargeChest) {
                             destinationInventory = new CraftInventoryDoubleChest((InventoryLargeChest) iinventory);
+                        // Paper start - avoid redundant snapshot creation of a TE
+                        } else if (iinventory instanceof TileEntity) {
+                            destinationInventory = ((TileEntity) iinventory).getOwner(false).getInventory();
                         } else {
                             destinationInventory = iinventory.getOwner().getInventory();
                         }
 
                         InventoryMoveItemEvent event =
-                                new InventoryMoveItemEvent(this.getOwner().getInventory(), oitemstack.clone(), destinationInventory, true);
+                                new InventoryMoveItemEvent(this.getOwner(false).getInventory(), oitemstack.clone(), destinationInventory, true);
+                        // Paper end - avoid redundant snapshot creation of a TE
                         this.getWorld().getServer().getPluginManager().callEvent(event);
 
                         if (event.isCancelled()) {
@@ -369,12 +373,23 @@ public class TileEntityHopper extends TileEntityLockableLoot implements IHopper,
 
             if (inventoryIn instanceof InventoryLargeChest) {
                 sourceInventory = new CraftInventoryDoubleChest((InventoryLargeChest) inventoryIn);
+            // Paper start - avoid redundant snapshot creation of a TE
+            } else if (inventoryIn instanceof TileEntity) {
+                sourceInventory = ((TileEntity) inventoryIn).getOwner(false).getInventory();
             } else {
                 sourceInventory = inventoryIn.getOwner().getInventory();
             }
 
+            Inventory destination;
+            if (hopper instanceof TileEntity) {
+                destination = ((TileEntity) hopper).getOwner(false).getInventory();
+            } else {
+                destination = hopper.getOwner().getInventory();
+            }
+
             InventoryMoveItemEvent event =
-                    new InventoryMoveItemEvent(sourceInventory, oitemstack.clone(), hopper.getOwner().getInventory(), false);
+                    new InventoryMoveItemEvent(sourceInventory, oitemstack.clone(), destination, false);
+            // Paper end - avoid redundant snapshot creation of a TE
             hopper.getWorld().getServer().getPluginManager().callEvent(event);
 
             if (event.isCancelled()) {
-- 
2.18.0

