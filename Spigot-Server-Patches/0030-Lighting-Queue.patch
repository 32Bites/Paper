From 930d5620d937d1d028237428cd5d6dff3ff41d1c Mon Sep 17 00:00:00 2001
From: Byteflux <byte@byteflux.net>
Date: Sun, 24 Sep 2017 16:16:38 -0400
Subject: [PATCH] Lighting Queue


diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index 1810f5d..84d74e8 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -49,6 +49,8 @@ public class WorldTimingsHandler {
     public final Timing worldSaveLevel;
     public final Timing chunkSaveData;
 
+    public final Timing lightingQueueTimer;
+
     public WorldTimingsHandler(World server) {
         String name = server.worldInfo.getWorldName() +" - ";
 
@@ -95,5 +97,7 @@ public class WorldTimingsHandler {
         tracker2 = Timings.ofSafe(name + "tracker stage 2");
         doTick = Timings.ofSafe(name + "doTick");
         tickEntities = Timings.ofSafe(name + "tickEntities");
+
+        lightingQueueTimer = Timings.ofSafe(name + "Lighting Queue");
     }
 }
diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index aa38baf..b46f505 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -135,4 +135,10 @@ public class PaperWorldConfig {
         netherVoidTopDamage = getBoolean( "nether-ceiling-void-damage", false );
         log("Top of the nether void damage: " + netherVoidTopDamage);
     }
+
+    public boolean queueLightUpdates;
+    private void queueLightUpdates() {
+        queueLightUpdates = getBoolean("queue-light-updates", false);
+        log("Lighting Queue enabled: " + queueLightUpdates);
+    }
 }
diff --git a/src/main/java/com/destroystokyo/paper/lighting/PaperLightingQueue.java b/src/main/java/com/destroystokyo/paper/lighting/PaperLightingQueue.java
new file mode 100644
index 0000000..aecdce1
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/lighting/PaperLightingQueue.java
@@ -0,0 +1,97 @@
+package com.destroystokyo.paper.lighting;
+
+import co.aikar.timings.Timing;
+import com.destroystokyo.paper.util.MCUtil;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.World;
+import net.minecraft.world.WorldServer;
+import net.minecraft.world.chunk.Chunk;
+
+import java.util.ArrayDeque;
+
+public class PaperLightingQueue {
+    private static final long MAX_TIME = (long) (1000000000 / 20 * .95);
+    private static int updatesThisTick;
+
+
+    public static void processQueue(long curTime) {
+        updatesThisTick = 0;
+
+        final long startTime = System.nanoTime();
+        final long maxTickTime = MAX_TIME - (startTime - curTime);
+
+        START:
+        for (World world : MinecraftServer.getServer().worlds) {
+            if (!world.paperConfig.queueLightUpdates) {
+                continue;
+            }
+
+            ObjectCollection<Chunk> loadedChunks = ((WorldServer) world).getChunkProvider().id2ChunkMap.values();
+            for (Chunk chunk : loadedChunks.toArray(new Chunk[loadedChunks.size()])) {
+                if (chunk.lightingQueue.processQueue(startTime, maxTickTime)) {
+                    break START;
+                }
+            }
+        }
+    }
+
+    public static class LightingQueue extends ArrayDeque<Runnable> {
+        final private Chunk chunk;
+
+        public LightingQueue(Chunk chunk) {
+            super();
+            this.chunk = chunk;
+        }
+
+        /**
+         * Processes the lighting queue for this chunk
+         *
+         * @param startTime If start Time is 0, we will not limit execution time
+         * @param maxTickTime Maximum time to spend processing lighting updates
+         * @return true to abort processing furthur lighting updates
+         */
+        private boolean processQueue(long startTime, long maxTickTime) {
+            if (this.isEmpty()) {
+                return false;
+            }
+            try (Timing ignored = chunk.world.timings.lightingQueueTimer.startTiming()) {
+                Runnable lightUpdate;
+                while ((lightUpdate = this.poll()) != null) {
+                    lightUpdate.run();
+                    if (startTime > 0 && ++PaperLightingQueue.updatesThisTick % 10 == 0 && PaperLightingQueue.updatesThisTick > 10) {
+                        if (System.nanoTime() - startTime > maxTickTime) {
+                            return true;
+                        }
+                    }
+                }
+            }
+
+            return false;
+        }
+
+        /**
+         * Flushes lighting updates to unload the chunk
+         */
+        public void processUnload() {
+            if (!chunk.world.paperConfig.queueLightUpdates) {
+                return;
+            }
+            processQueue(0, 0); // No timeout
+
+            final int radius = 1; // TODO: bitflip, why should this ever be 2?
+            for (int x = chunk.x - radius; x <= chunk.x + radius; ++x) {
+                for (int z = chunk.z - radius; z <= chunk.z + radius; ++z) {
+                    if (x == chunk.x && z == chunk.z) {
+                        continue;
+                    }
+
+                    Chunk neighbor = MCUtil.getLoadedChunkWithoutMarkingActive(chunk.world, x, z);
+                    if (neighbor != null) {
+                        neighbor.lightingQueue.processQueue(0, 0); // No timeout
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 985fdfd..4aa18db 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import com.destroystokyo.paper.lighting.PaperLightingQueue;
 import com.google.common.collect.Lists;
 import com.google.common.io.Files;
 import com.google.common.util.concurrent.Futures;
@@ -104,7 +105,6 @@ import org.bukkit.event.world.WorldInitEvent;
 import org.bukkit.event.world.WorldLoadEvent;
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.plugin.PluginLoadOrder;
-import org.spigotmc.CustomTimingsHandler;
 import org.spigotmc.SlackActivityAccountant;
 import org.spigotmc.SpigotConfig;
 import org.spigotmc.WatchdogThread;
@@ -755,6 +755,7 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.startTiming(); // Paper
         this.slackActivityAccountant.tickStarted();
         long i = System.nanoTime();
+        long startTime = i; // Paper - Queue lighting updates
         ++this.tickCounter;
 
         if (this.startProfiling) {
@@ -810,6 +811,7 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
         this.profiler.endSection();
         this.profiler.endSection();
         WatchdogThread.tick();
+        PaperLightingQueue.processQueue(startTime); // Paper - Queue lighting updates
         this.slackActivityAccountant.tickEnded(tickNanos);
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
     }
diff --git a/src/main/java/net/minecraft/world/World.java b/src/main/java/net/minecraft/world/World.java
index b8d09c3..c7432c6 100644
--- a/src/main/java/net/minecraft/world/World.java
+++ b/src/main/java/net/minecraft/world/World.java
@@ -476,7 +476,7 @@ public abstract class World implements IBlockAccess {
                 if (newState.getLightOpacity() != iblockdata1.getLightOpacity()
                         || newState.getLightValue() != iblockdata1.getLightValue()) {
                     this.profiler.startSection("checkLight");
-                    this.checkLight(pos);
+                    chunk.runOrQueueLightUpdate(() -> this.checkLight(pos)); // Paper - Queue light updates
                     this.profiler.endSection();
                 }
 
diff --git a/src/main/java/net/minecraft/world/chunk/Chunk.java b/src/main/java/net/minecraft/world/chunk/Chunk.java
index 1a062b5..912d746 100644
--- a/src/main/java/net/minecraft/world/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/chunk/Chunk.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.chunk;
 
+import com.destroystokyo.paper.lighting.PaperLightingQueue; // Paper
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
@@ -88,6 +89,7 @@ public class Chunk {
     public long chunkKey;
     public org.bukkit.Chunk bukkitChunk;
     public boolean mustSave;
+    public final PaperLightingQueue.LightingQueue lightingQueue = new PaperLightingQueue.LightingQueue(this); // Paper
 
     public boolean areNeighborsLoaded(int radius) {
         switch (radius) {
@@ -254,6 +256,14 @@ public class Chunk {
         this.world.profiler.startSection("recheckGaps");
 
         if (this.world.isAreaLoaded(new BlockPos(this.x * 16 + 8, 0, this.z * 16 + 8), 16)) {
+            // Paper start - Queue light updates
+             this.runOrQueueLightUpdate(() -> recheckGapsVanilla(onlyOne));
+        }
+    }
+
+    private void recheckGapsVanilla(boolean onlyOne) {
+        if (true) {
+            // Paper end
             for (int i = 0; i < 16; ++i) {
                 for (int j = 0; j < 16; ++j) {
                     if (this.updateSkylightColumns[i + j * 16]) {
@@ -501,7 +511,7 @@ public class Chunk {
             } else {
                 if (flag) {
                     this.generateSkylightMap();
-                } else {
+                } else { this.runOrQueueLightUpdate(() -> { // paper - Queue light updates
                     int j1 = state.getLightOpacity();
                     int k1 = iblockdata1.getLightOpacity();
 
@@ -517,6 +527,7 @@ public class Chunk {
                             && (j1 < k1 || this.getLightFor(EnumSkyBlock.SKY, pos) > 0 || this.getLightFor(EnumSkyBlock.BLOCK, pos) > 0)) {
                         this.propagateSkylightOcclusion(i, k);
                     }
+                    });
                 }
 
                 if (block1 instanceof ITileEntityProvider) {
@@ -1336,6 +1347,15 @@ public class Chunk {
         this.inhabitedTime = newInhabitedTime;
     }
 
+    // Paper start - Lighting queue
+    public void runOrQueueLightUpdate(Runnable runnable) {
+        if (this.world.paperConfig.queueLightUpdates) {
+            this.lightingQueue.add(runnable);
+        } else {
+            runnable.run();
+        }
+    }
+
     public static enum EnumCreateEntityType {
         IMMEDIATE,
         QUEUED,
diff --git a/src/main/java/net/minecraft/world/gen/ChunkProviderServer.java b/src/main/java/net/minecraft/world/gen/ChunkProviderServer.java
index f4c54e7..ee6744a 100644
--- a/src/main/java/net/minecraft/world/gen/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/world/gen/ChunkProviderServer.java
@@ -275,6 +275,7 @@ public class ChunkProviderServer implements IChunkProvider {
             return false;
         } else {
             save = event.isSaveChunk();
+            chunk.lightingQueue.processUnload(); // Paper
 
             for (int x = -2; x < 3; ++x) {
                 for (int z = -2; z < 3; ++z) {
-- 
2.18.0

