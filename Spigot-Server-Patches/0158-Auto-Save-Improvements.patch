From 837dcccc9d3d571166ac9887fb79330a7c316587 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Tue, 10 Oct 2017 16:31:05 -0400
Subject: [PATCH] Auto Save Improvements

Makes Auto Save Rate setting configurable per-world. If the auto save rate is left -1, the global bukkit.yml value will be used.

Process auto save every tick instead of once per auto tick interval, so that chunk saves will distribute over many ticks instead of all at once.

Re-introduce a cap per tick for auto save (Spigot disabled the vanilla cap) and make it configurable.

Adds incremental player auto saving too

diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 621c585..da0984a 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -251,4 +251,9 @@ public class PaperConfig {
         flyingKickPlayerMessage = getString("messages.kick.flying-player", flyingKickPlayerMessage);
         flyingKickVehicleMessage = getString("messages.kick.flying-vehicle", flyingKickVehicleMessage);
     }
+
+    public static int playerAutoSaveRate = -1;
+    private static void playerAutoSaveRate() {
+        playerAutoSaveRate = getInt("settings.player-auto-save-rate", -1);
+    }
 }
diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 98abb04..4b12112 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -2,6 +2,7 @@ package com.destroystokyo.paper;
 
 import java.util.List;
 
+import net.minecraft.server.MinecraftServer;
 import org.bukkit.configuration.file.YamlConfiguration;
 import org.spigotmc.SpigotWorldConfig;
 
@@ -354,4 +355,19 @@ public class PaperWorldConfig {
     private void elytraHitWallDamage() {
         elytraHitWallDamage = getBoolean("elytra-hit-wall-damage", true);
     }
+
+    public int autoSavePeriod = -1;
+    private void autoSavePeriod() {
+        autoSavePeriod = getInt("auto-save-interval", -1);
+        if (autoSavePeriod > 0) {
+            log("Auto Save Interval: " +autoSavePeriod + " (" + (autoSavePeriod / 20) + "s)");
+        } else if (autoSavePeriod < 0) {
+            autoSavePeriod = MinecraftServer.getServer().autosavePeriod;
+        }
+    }
+
+    public int maxAutoSaveChunksPerTick = 24;
+    private void maxAutoSaveChunksPerTick() {
+        maxAutoSaveChunksPerTick = getInt("max-auto-save-chunks-per-tick", 24);
+    }
 }
diff --git a/src/main/java/net/minecraft/entity/player/EntityPlayerMP.java b/src/main/java/net/minecraft/entity/player/EntityPlayerMP.java
index 3b47f9d..0bb0378 100644
--- a/src/main/java/net/minecraft/entity/player/EntityPlayerMP.java
+++ b/src/main/java/net/minecraft/entity/player/EntityPlayerMP.java
@@ -200,6 +200,7 @@ public class EntityPlayerMP extends EntityPlayer implements IContainerListener {
     }
     // Paper end
     private int containerUpdateDelay; // Paper
+    public long lastSave = MinecraftServer.currentTick; // Paper
 
     public EntityPlayerMP(MinecraftServer server, WorldServer worldIn, GameProfile profile, PlayerInteractionManager interactionManagerIn) {
         super(worldIn, profile);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index e06bc5b..db4ab61 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -178,6 +178,7 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
     public final SlackActivityAccountant slackActivityAccountant = new SlackActivityAccountant();
     private boolean hasStopped = false;
     private final Object stopLock = new Object();
+    public boolean serverAutoSave = false; // Paper
 
     public MinecraftServer(
             OptionSet p_i35_1_,
@@ -797,18 +798,26 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IThre
             this.statusResponse.getPlayers().setPlayers(agameprofile);
         }
 
-        if (this.autosavePeriod > 0 && this.tickCounter % this.autosavePeriod == 0) {
             this.profiler.startSection("save");
-            this.playerList.saveAllPlayerData();
+
+        // Paper start - - Incremental Auto Saving
+        serverAutoSave = (autosavePeriod > 0 && this.tickCounter % autosavePeriod == 0); // Paper
+        int playerSaveInterval = com.destroystokyo.paper.PaperConfig.playerAutoSaveRate;
+        if (playerSaveInterval < 0) {
+            playerSaveInterval = autosavePeriod;
+        }
+        if (playerSaveInterval > 0) { // CraftBukkit // Paper
             this.server.playerCommandState = true;
+        }
+        // Paper end
 
             for (World world : this.worlds) {
-                world.getWorld().save(false);
+                if (world.paperConfig.autoSavePeriod > 0) world.getWorld().save(false);  // Paper - Incremental / Configurable Auto Saving
             }
 
             this.server.playerCommandState = false;
             this.profiler.endSection();
-        }
+        //} // Paper - Incremental Auto Saving
 
         this.profiler.startSection("tallying");
         long tickNanos;
diff --git a/src/main/java/net/minecraft/server/management/PlayerList.java b/src/main/java/net/minecraft/server/management/PlayerList.java
index 58b80ec..45dbda8 100644
--- a/src/main/java/net/minecraft/server/management/PlayerList.java
+++ b/src/main/java/net/minecraft/server/management/PlayerList.java
@@ -397,6 +397,7 @@ public abstract class PlayerList {
     }
 
     protected void writePlayerData(EntityPlayerMP playerIn) {
+        playerIn.lastSave = MinecraftServer.currentTick; // Paper
         this.playerDataManager.writePlayerData(playerIn);
         StatisticsManagerServer serverstatisticmanager = playerIn.getStatFile();
 
@@ -1132,13 +1133,23 @@ public abstract class PlayerList {
         }
     }
 
+    // Paper start
     public void saveAllPlayerData() {
+        saveAllPlayerData(null);
+    }
+
+    public void saveAllPlayerData(@Nullable Integer interval) {
+        long now = MinecraftServer.currentTick;
         MinecraftTimings.savePlayers.startTiming(); // Paper
         for (int i = 0; i < this.playerEntityList.size(); ++i) {
-            this.writePlayerData(this.playerEntityList.get(i));
+            EntityPlayerMP player = this.playerEntityList.get(i);
+            if (interval == null || now - player.lastSave >= interval) {
+                this.writePlayerData(this.playerEntityList.get(i));
+            }
         }
         MinecraftTimings.savePlayers.stopTiming(); // Paper
     }
+    // Paper end
 
     public void addWhitelistedPlayer(GameProfile profile) {
         this.whiteListedPlayers.addEntry(new UserListWhitelistEntry(profile));
diff --git a/src/main/java/net/minecraft/world/WorldServer.java b/src/main/java/net/minecraft/world/WorldServer.java
index 8d47390..f3af5ee 100644
--- a/src/main/java/net/minecraft/world/WorldServer.java
+++ b/src/main/java/net/minecraft/world/WorldServer.java
@@ -1103,8 +1103,9 @@ public class WorldServer extends World implements IThreadListener {
 
         timings.worldSave.startTiming(); // Paper
         if (chunkproviderserver.canSave()) {
-            Bukkit.getPluginManager().callEvent(new WorldSaveEvent(this.getWorld()));
+            if (all) Bukkit.getPluginManager().callEvent(new WorldSaveEvent(this.getWorld())); // Paper - Incremental Auto Saving - Only fire event on full save
 
+            if (all || mcServer.serverAutoSave) { // Paper
             if (progressCallback != null) {
                 progressCallback.displaySavingString("Saving level");
             }
@@ -1114,6 +1115,7 @@ public class WorldServer extends World implements IThreadListener {
             if (progressCallback != null) {
                 progressCallback.displayLoadingString("Saving chunks");
             }
+            } // Paper
 
             timings.worldSaveChunks.startTiming(); // Paper
             chunkproviderserver.saveChunks(all);
diff --git a/src/main/java/net/minecraft/world/chunk/Chunk.java b/src/main/java/net/minecraft/world/chunk/Chunk.java
index eacd2b9..6b9ce17 100644
--- a/src/main/java/net/minecraft/world/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/chunk/Chunk.java
@@ -959,12 +959,9 @@ public class Chunk {
             if (this.hasEntities && this.world.getTotalWorldTime() != this.lastSaveTime || this.dirty) {
                 return true;
             }
-        } else if (this.hasEntities
-                && this.world.getTotalWorldTime() >= this.lastSaveTime + (long) (MinecraftServer.getServer().autosavePeriod * 4)) {
-            return true;
         }
 
-        return this.dirty;
+        return ((this.dirty || this.hasEntities) && this.world.getTotalWorldTime() >= this.lastSaveTime + world.paperConfig.autoSavePeriod); // Paper - Make world configurable and incremental
     }
 
     public Random getRandomWithSeed(long seed) {
diff --git a/src/main/java/net/minecraft/world/gen/ChunkProviderServer.java b/src/main/java/net/minecraft/world/gen/ChunkProviderServer.java
index 6d9bce4..2574147 100644
--- a/src/main/java/net/minecraft/world/gen/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/world/gen/ChunkProviderServer.java
@@ -254,7 +254,8 @@ public class ChunkProviderServer implements IChunkProvider {
                 chunk.setModified(false);
                 ++i;
 
-                if (i == 24 && !all) {;
+                if (!all && i >= world.paperConfig.maxAutoSaveChunksPerTick) { // Spigot - // Paper - Incremental Auto Save - cap max per tick
+                    return false;
                 }
             }
         }
-- 
2.18.0

