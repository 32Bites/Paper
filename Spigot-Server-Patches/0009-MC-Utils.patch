From 9bf7501a3986441a5f2c9f2cfaf9a6db1ef8730f Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Mon, 28 Mar 2016 20:55:47 -0400
Subject: [PATCH] MC Utils


diff --git a/src/main/java/com/destroystokyo/paper/util/MCUtil.java b/src/main/java/com/destroystokyo/paper/util/MCUtil.java
new file mode 100644
index 0000000..7eae351
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/MCUtil.java
@@ -0,0 +1,241 @@
+package com.destroystokyo.paper.util;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import net.minecraft.entity.Entity;
+import net.minecraft.init.Blocks;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.tileentity.TileEntityHopper;
+import net.minecraft.util.math.BlockPos;
+import net.minecraft.util.math.ChunkPos;
+import net.minecraft.world.World;
+import net.minecraft.world.chunk.Chunk;
+import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.ChunkProviderServer;
+import org.apache.commons.lang.exception.ExceptionUtils;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.util.Waitable;
+import org.spigotmc.AsyncCatcher;
+
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import java.util.function.Supplier;
+
+public final class MCUtil {
+    private static final Executor asyncExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("Paper Async Task Handler Thread - %1$d").build());
+
+    private MCUtil() {}
+
+    /**
+     * Quickly generate a stack trace for current location
+     *
+     * @return Stacktrace
+     */
+    public static String stack() {
+        return ExceptionUtils.getFullStackTrace(new Throwable());
+    }
+
+    /**
+     * Quickly generate a stack trace for current location with message
+     *
+     * @param str
+     * @return Stacktrace
+     */
+    public static String stack(String str) {
+        return ExceptionUtils.getFullStackTrace(new Throwable(str));
+    }
+
+    /**
+     * Ensures the target code is running on the main thread
+     *
+     * @param reason
+     * @param run
+     * @param <T>
+     * @return
+     */
+    public static <T> T ensureMain(String reason, Supplier<T> run) {
+        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread) {
+            new IllegalStateException("Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
+            Waitable<T> wait = new Waitable<T>() {
+                @Override
+                protected T evaluate() {
+                    return run.get();
+                }
+            };
+            MinecraftServer.getServer().processQueue.add(wait);
+            try {
+                return wait.get();
+            } catch (InterruptedException | ExecutionException e) {
+                e.printStackTrace();
+            }
+            return null;
+        }
+        return run.get();
+    }
+
+    /**
+     * Calculates distance between 2 entities
+     *
+     * @param e1
+     * @param e2
+     * @return
+     */
+    public static double distance(Entity e1, Entity e2) {
+        return Math.sqrt(distanceSq(e1, e2));
+    }
+
+
+    /**
+     * Calculates distance between 2 block positions
+     *
+     * @param e1
+     * @param e2
+     * @return
+     */
+    public static double distance(BlockPos e1, BlockPos e2) {
+        return Math.sqrt(distanceSq(e1, e2));
+    }
+
+    /**
+     * Gets the distance between 2 positions
+     *
+     * @param x1
+     * @param y1
+     * @param z1
+     * @param x2
+     * @param y2
+     * @param z2
+     * @return
+     */
+    public static double distance(double x1, double y1, double z1, double x2, double y2, double z2) {
+        return Math.sqrt(distanceSq(x1, y1, z1, x2, y2, z2));
+    }
+
+    /**
+     * Get's the distance squared between 2 entities
+     *
+     * @param e1
+     * @param e2
+     * @return
+     */
+    public static double distanceSq(Entity e1, Entity e2) {
+        return distanceSq(e1.posX, e1.posY, e1.posZ, e2.posX, e2.posY, e2.posZ);
+    }
+
+    /**
+     * Gets the distance sqaured between 2 block positions
+     *
+     * @param pos1
+     * @param pos2
+     * @return
+     */
+    public static double distanceSq(BlockPos pos1, BlockPos pos2) {
+        return distanceSq(pos1.getX(), pos1.getY(), pos1.getZ(), pos2.getX(), pos2.getY(), pos2.getZ());
+    }
+
+    /**
+     * Gets the distance squared between 2 positions
+     *
+     * @param x1
+     * @param y1
+     * @param z1
+     * @param x2
+     * @param y2
+     * @param z2
+     * @return
+     */
+    public static double distanceSq(double x1, double y1, double z1, double x2, double y2, double z2) {
+        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2);
+    }
+
+    /**
+     * Converts a NMS World/BlockPosition to Bukkit Location
+     *
+     * @param world
+     * @param pos
+     * @return
+     */
+    public static Location toLocation(World world, BlockPos pos) {
+        return new Location(world.getWorld(), pos.getX(), pos.getY(), pos.getZ());
+    }
+
+    /**
+     * Converts an NMS entity's current location to a Bukkit Location
+     *
+     * @param entity
+     * @return
+     */
+    public static Location toLocation(Entity entity) {
+        return new Location(entity.getEntityWorld().getWorld(), entity.posX, entity.posY, entity.posZ);
+    }
+
+    public static BlockPos toBlockPosition(Location loc) {
+        return new BlockPos(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ());
+    }
+
+    public static boolean isEdgeOfChunk(BlockPos pos) {
+        final int modX = pos.getX() & 15;
+        final int modZ = pos.getZ() & 15;
+        return (modX == 0 || modX == 15 || modZ == 0 || modZ == 15);
+    }
+
+    /**
+     * Gets a chunk without changing its boolean for should unload
+     *
+     * @param world
+     * @param x
+     * @param z
+     * @return
+     */
+    @Nullable
+    public static Chunk getLoadedChunkWithoutMarkingActive(World world, int x, int z) {
+        return ((ChunkProviderServer) world.chunkProvider).id2ChunkMap.get(ChunkPos.asLong(x, z));
+    }
+
+    /**
+     * Gets a chunk without changing its boolean for should unload
+     *
+     * @param provider
+     * @param x
+     * @param z
+     * @return
+     */
+    @Nullable
+    public static Chunk getLoadedChunkWithoutMarkingActive(IChunkProvider provider, int x, int z) {
+        return ((ChunkProviderServer) provider).id2ChunkMap.get(ChunkPos.asLong(x, z));
+    }
+
+    /**
+     * Posts a task to be executed asynchronously
+     *
+     * @param run
+     */
+    public static void scheduleAsyncTask(Runnable run) {
+        asyncExecutor.execute(run);
+    }
+
+    @Nullable
+    public static TileEntityHopper getHopper(World world, BlockPos pos) {
+        Chunk chunk = world.getChunkIfLoaded(pos.getX() >> 4, pos.getZ() >> 4);
+        if (chunk != null && chunk.getBlockState(pos).getBlock() == Blocks.HOPPER) {
+            TileEntity tileEntity = chunk.getTileEntityImmediately(pos);
+            if (tileEntity instanceof TileEntityHopper) {
+                return (TileEntityHopper) tileEntity;
+            }
+        }
+        return null;
+    }
+
+    @Nonnull
+    public static World getNMSWorld(@Nonnull org.bukkit.World world) {
+        return ((CraftWorld) world).getHandle();
+    }
+
+    public static World getNMSWorld(@Nonnull org.bukkit.entity.Entity entity) {
+        return getNMSWorld(entity.getWorld());
+    }
+}
diff --git a/src/main/java/net/minecraft/util/math/ChunkPos.java b/src/main/java/net/minecraft/util/math/ChunkPos.java
index 8d5e2a0..a92a371 100644
--- a/src/main/java/net/minecraft/util/math/ChunkPos.java
+++ b/src/main/java/net/minecraft/util/math/ChunkPos.java
@@ -16,6 +16,12 @@ public class ChunkPos {
         this.z = pos.getZ() >> 4;
     }
 
+    // Paper start - Convenience method
+    public static long asLong(BlockPos pos) {
+        return asLong(pos.getX() >> 4, pos.getZ() >> 4);
+    }
+    // Paper end
+
     public static long asLong(int x, int z) {
         return (long) x & 4294967295L | ((long) z & 4294967295L) << 32;
     }
diff --git a/src/main/java/net/minecraft/world/chunk/Chunk.java b/src/main/java/net/minecraft/world/chunk/Chunk.java
index 3545a43..0bffb2c 100644
--- a/src/main/java/net/minecraft/world/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/chunk/Chunk.java
@@ -697,6 +697,12 @@ public class Chunk {
                 : ((ITileEntityProvider) block).createNewTileEntity(this.world, iblockdata.getBlock().getMetaFromState(iblockdata));
     }
 
+    // Paper start - Convenience Method
+    @Nullable public final TileEntity getTileEntityImmediately(BlockPos pos) {
+        return this.getTileEntity(pos, EnumCreateEntityType.IMMEDIATE);
+    }
+    // Paper end
+
     @Nullable
     public TileEntity getTileEntity(BlockPos pos, Chunk.EnumCreateEntityType p_177424_2_) {
         TileEntity tileentity = null;
-- 
2.18.0

