From f05f96e69afebdfd8bd7e66f5daf0cc073b616a7 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sat, 30 Sep 2017 23:24:14 -0400
Subject: [PATCH] Add World Util Methods

Methods that can be used for other patches to help improve logic.

diff --git a/src/main/java/net/minecraft/world/World.java b/src/main/java/net/minecraft/world/World.java
index bf006cb..123594a 100644
--- a/src/main/java/net/minecraft/world/World.java
+++ b/src/main/java/net/minecraft/world/World.java
@@ -7,11 +7,6 @@ import com.google.common.base.MoreObjects;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-
-import java.util.*;
-import java.util.function.Supplier;
-import javax.annotation.Nullable;
-
 import com.google.common.collect.Sets;
 import net.minecraft.advancements.AdvancementManager;
 import net.minecraft.advancements.FunctionManager;
@@ -46,19 +41,8 @@ import net.minecraft.profiler.Profiler;
 import net.minecraft.scoreboard.Scoreboard;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.tileentity.TileEntity;
-import net.minecraft.util.EntitySelectors;
-import net.minecraft.util.EnumFacing;
-import net.minecraft.util.EnumParticleTypes;
-import net.minecraft.util.ITickable;
-import net.minecraft.util.IntHashMap;
-import net.minecraft.util.ReportedException;
-import net.minecraft.util.SoundCategory;
-import net.minecraft.util.SoundEvent;
-import net.minecraft.util.math.AxisAlignedBB;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.RayTraceResult;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.*;
+import net.minecraft.util.math.*;
 import net.minecraft.village.VillageCollection;
 import net.minecraft.world.biome.Biome;
 import net.minecraft.world.biome.BiomeProvider;
@@ -68,11 +52,7 @@ import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.IChunkProvider;
 import net.minecraft.world.gen.ChunkProviderServer;
 import net.minecraft.world.gen.structure.StructureBoundingBox;
-import net.minecraft.world.storage.ISaveHandler;
-import net.minecraft.world.storage.MapData;
-import net.minecraft.world.storage.MapStorage;
-import net.minecraft.world.storage.WorldInfo;
-import net.minecraft.world.storage.WorldSavedData;
+import net.minecraft.world.storage.*;
 import net.minecraft.world.storage.loot.LootTableManager;
 import org.bukkit.Bukkit;
 import org.bukkit.World.Environment;
@@ -82,7 +62,6 @@ import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHashSet; // Paper
 import org.bukkit.entity.Projectile;
 import org.bukkit.entity.Vehicle;
 import org.bukkit.event.Cancellable;
@@ -95,6 +74,9 @@ import org.spigotmc.AsyncCatcher;
 import org.spigotmc.SpigotWorldConfig;
 import org.spigotmc.TickLimiter;
 
+import javax.annotation.Nullable;
+import java.util.*;
+
 public abstract class World implements IBlockAccess {
     private int seaLevel = 63;
     protected boolean scheduledUpdatesAreImmediate;
@@ -3218,4 +3200,65 @@ public abstract class World implements IBlockAccess {
     public BlockPos findNearestStructure(String p_190528_1_, BlockPos p_190528_2_, boolean p_190528_3_) {
         return null;
     }
+
+    // Paper start - World util methods
+    @Nullable
+    public Chunk getChunkIfLoaded(BlockPos pos) {
+        return this.chunkProvider.getLoadedChunk(pos.getX() >> 4, pos.getZ() >> 4);
+    }
+
+    // Test if meets light level, return faster
+    public boolean isLightLevel(BlockPos pos, int level) {
+        if (isValid(pos)) {
+            if (this.getBlockState(pos).useNeighborBrightness()) {
+                if (this.getLight(pos.up(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(pos.east(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(pos.west(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(pos.south(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(pos.north(), false) >= level) {
+                    return true;
+                }
+                return false;
+            } else {
+                if (pos.getY() >= 256) {
+                    pos = new BlockPos(pos.getX(), 255, pos.getZ());
+                }
+
+                Chunk chunk = this.getChunkFromBlockCoords(pos);
+                return chunk.getLightSubtracted(pos, this.getSkylightSubtracted()) >= level;
+            }
+        } else {
+            return true;
+        }
+    }
+
+    // Reduces need to do isLoaded before getType
+    @Nullable
+    public IBlockState getStateIfLoaded(BlockPos pos) {
+        // CraftBukkit start - tree generation
+        if (captureTreeGeneration) {
+            Iterator<BlockState> it = capturedBlockStates.iterator();
+            while (it.hasNext()) {
+                BlockState previous = it.next();
+                if (previous.getX() == pos.getX() && previous.getY() == pos.getY() && previous.getZ() == pos.getZ()) {
+                    return CraftMagicNumbers.getBlock(previous.getTypeId()).getStateFromMeta(previous.getRawData());
+                }
+            }
+        }
+        // CraftBukkit end
+        Chunk chunk = this.getChunkIfLoaded(pos);
+        if (chunk != null) {
+            return this.isValid(pos) ? chunk.getBlockState(pos) : Blocks.AIR.getDefaultState();
+        }
+        return null;
+    }
+    // Paper end
 }
-- 
2.18.0

