From 61bc07735639f15b9c4b79b906eb8a37412e5e37 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sun, 1 Oct 2017 00:58:57 -0400
Subject: [PATCH] Optimize isValidLocation, getType and getBlockData for inling

Hot methods, so reduce # of instructions for the method.

Move is valid location test to the BlockPosition class so that it can access local variables.

Replace all calls to the new place to the unnecessary forward.

Optimize getType and getBlockData to manually inline and optimize the calls

diff --git a/src/main/java/net/minecraft/util/math/BlockPos.java b/src/main/java/net/minecraft/util/math/BlockPos.java
index f245a0b..eb851df 100644
--- a/src/main/java/net/minecraft/util/math/BlockPos.java
+++ b/src/main/java/net/minecraft/util/math/BlockPos.java
@@ -254,6 +254,16 @@ public class BlockPos extends Vec3i {
         protected int x;
         protected int y;
         protected int z;
+        // Paper start
+        @Override
+        public boolean isValidLocation() {
+            return x >= -30000000 && z >= -30000000 && x < 30000000 && z < 30000000 && y >= 0 && y < 256;
+        }
+        @Override
+        public boolean isInvalidYLocation() {
+            return y < 0 || y >= 256;
+        }
+        // Paper end
 
         public MutableBlockPos() {
             this(0, 0, 0);
diff --git a/src/main/java/net/minecraft/util/math/Vec3i.java b/src/main/java/net/minecraft/util/math/Vec3i.java
index f3230c4..37bf6fb 100644
--- a/src/main/java/net/minecraft/util/math/Vec3i.java
+++ b/src/main/java/net/minecraft/util/math/Vec3i.java
@@ -9,6 +9,14 @@ public class Vec3i implements Comparable<Vec3i> {
     protected int x;
     protected int y;
     protected int z;
+    // Paper start
+    public boolean isValidLocation() {
+        return x >= -30000000 && z >= -30000000 && x < 30000000 && z < 30000000 && y >= 0 && y < 256;
+    }
+    public boolean isInvalidYLocation() {
+        return y < 0 || y >= 256;
+    }
+    // Paper end
 
     public Vec3i(int xIn, int yIn, int zIn) {
         this.x = xIn;
diff --git a/src/main/java/net/minecraft/world/World.java b/src/main/java/net/minecraft/world/World.java
index 123594a..e7ed8ca 100644
--- a/src/main/java/net/minecraft/world/World.java
+++ b/src/main/java/net/minecraft/world/World.java
@@ -317,16 +317,12 @@ public abstract class World implements IBlockAccess {
         return this.getBlockState(blockposition1);
     }
 
-    private boolean isValid(BlockPos pos) {
-        return !this.isOutsideBuildHeight(pos)
-                && pos.getX() >= -30000000
-                && pos.getZ() >= -30000000
-                && pos.getX() < 30000000
-                && pos.getZ() < 30000000;
+    private static boolean isValid(BlockPos pos) {
+        return pos.isValidLocation(); // Paper
     }
 
-    private boolean isOutsideBuildHeight(BlockPos pos) {
-        return pos.getY() < 0 || pos.getY() >= 256;
+    private static boolean isOutsideBuildHeight(BlockPos pos) {
+        return pos.isInvalidYLocation(); // Paper
     }
 
     public boolean isAirBlock(BlockPos pos) {
@@ -430,7 +426,7 @@ public abstract class World implements IBlockAccess {
             blockstate.setRawData((byte) newState.getBlock().getMetaFromState(newState));
             this.capturedBlockStates.add(blockstate);
             return true;
-        } else if (this.isOutsideBuildHeight(pos)) {
+        } else if (pos.isInvalidYLocation()) {
             return false;
         } else if (!this.isRemote && this.worldInfo.getTerrainType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             return false;
@@ -812,7 +808,7 @@ public abstract class World implements IBlockAccess {
             pos = new BlockPos(pos.getX(), 0, pos.getZ());
         }
 
-        if (!this.isValid(pos)) {
+        if (!pos.isValidLocation()) {
             return type.defaultLightValue;
         } else if (!this.isBlockLoaded(pos)) {
             return type.defaultLightValue;
@@ -823,7 +819,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public void setLightFor(EnumSkyBlock type, BlockPos pos, int lightValue) {
-        if (this.isValid(pos) && this.isBlockLoaded(pos)) {
+        if (pos.isValidLocation() && this.isBlockLoaded(pos)) {
             Chunk chunk = this.getChunkFromBlockCoords(pos);
             chunk.setLightFor(type, pos, lightValue);
             this.notifyLightSet(pos);
@@ -849,7 +845,7 @@ public abstract class World implements IBlockAccess {
             }
         }
 
-        if (this.isOutsideBuildHeight(pos)) {
+        if (pos.isInvalidYLocation()) {
             return Blocks.AIR.getDefaultState();
         } else {
             Chunk chunk = this.getChunkFromBlockCoords(pos);
@@ -2030,7 +2026,7 @@ public abstract class World implements IBlockAccess {
 
     @Nullable
     public TileEntity getTileEntity(BlockPos pos) {
-        if (this.isOutsideBuildHeight(pos)) {
+        if (pos.isInvalidYLocation()) {
             return null;
         } else if (this.capturedTileEntities.containsKey(pos)) {
             return this.capturedTileEntities.get(pos);
@@ -2067,7 +2063,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public void setTileEntity(BlockPos pos, @Nullable TileEntity tileEntityIn) {
-        if (!this.isOutsideBuildHeight(pos) && tileEntityIn != null && !tileEntityIn.isInvalid()) {
+        if (!pos.isInvalidYLocation() && tileEntityIn != null && !tileEntityIn.isInvalid()) {
             if (this.captureBlockStates) {
                 tileEntityIn.setWorld(this);
                 tileEntityIn.setPos(pos);
@@ -2124,7 +2120,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean isBlockNormalCube(BlockPos pos, boolean _default) {
-        if (this.isOutsideBuildHeight(pos)) {
+        if (pos.isInvalidYLocation()) {
             return false;
         } else {
             Chunk chunk = this.chunkProvider.getLoadedChunk(pos.getX() >> 4, pos.getZ() >> 4);
@@ -3209,7 +3205,7 @@ public abstract class World implements IBlockAccess {
 
     // Test if meets light level, return faster
     public boolean isLightLevel(BlockPos pos, int level) {
-        if (isValid(pos)) {
+        if (pos.isValidLocation()) {
             if (this.getBlockState(pos).useNeighborBrightness()) {
                 if (this.getLight(pos.up(), false) >= level) {
                     return true;
@@ -3243,20 +3239,28 @@ public abstract class World implements IBlockAccess {
     // Reduces need to do isLoaded before getType
     @Nullable
     public IBlockState getStateIfLoaded(BlockPos pos) {
+        final int x = pos.getX();
+        final int y = pos.getY();
+        final int z = pos.getZ();
         // CraftBukkit start - tree generation
         if (captureTreeGeneration) {
-            Iterator<BlockState> it = capturedBlockStates.iterator();
-            while (it.hasNext()) {
-                BlockState previous = it.next();
-                if (previous.getX() == pos.getX() && previous.getY() == pos.getY() && previous.getZ() == pos.getZ()) {
-                    return CraftMagicNumbers.getBlock(previous.getTypeId()).getStateFromMeta(previous.getRawData());
-                }
+            final IBlockState previous = getCapturedBlockType(x, y, z);
+            if (previous != null) {
+                return previous;
             }
         }
         // CraftBukkit end
-        Chunk chunk = this.getChunkIfLoaded(pos);
-        if (chunk != null) {
-            return this.isValid(pos) ? chunk.getBlockState(pos) : Blocks.AIR.getDefaultState();
+        return this.chunkProvider.provideChunk(x >> 4, z >> 4).getBlockState(x, y, z);
+    }
+
+    @Nullable
+    private IBlockState getCapturedBlockType(int x, int y, int z) {
+        Iterator<BlockState> it = capturedBlockStates.iterator();
+        while (it.hasNext()) {
+            BlockState previous = it.next();
+            if (previous.getX() == x && previous.getY() == y && previous.getZ() == z) {
+                return CraftMagicNumbers.getBlock(previous.getTypeId()).getStateFromMeta(previous.getRawData());
+            }
         }
         return null;
     }
diff --git a/src/main/java/net/minecraft/world/chunk/Chunk.java b/src/main/java/net/minecraft/world/chunk/Chunk.java
index 4a41e4d..4012467 100644
--- a/src/main/java/net/minecraft/world/chunk/Chunk.java
+++ b/src/main/java/net/minecraft/world/chunk/Chunk.java
@@ -425,11 +425,23 @@ public class Chunk {
         return this.getBlockState(x, y, z).getLightOpacity();
     }
 
-    public IBlockState getBlockState(BlockPos pos) {
+    // Paper start - Optimize getBlockState to reduce instructions
+    public final IBlockState getBlockState(final BlockPos pos) {
         return this.getBlockState(pos.getX(), pos.getY(), pos.getZ());
     }
 
     public IBlockState getBlockState(final int x, final int y, final int z) {
+        // Method body / logic copied from below
+        final int i = y >> 4;
+        if (y >= 0 && i < this.storageArrays.length && this.storageArrays[i] != null) {
+            // Inlined ExtendedBlockStorage.get() and BlockStateContainer.read(int, int, int)
+            return this.storageArrays[i].data.get((y & 15) << 8 | (z & 15) << 4 | x & 15);
+        }
+        return Blocks.AIR.getDefaultState();
+    }
+
+    public IBlockState unused(final int x, final int y, final int z) {
+    // Paper end
         if (this.world.getWorldType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             IBlockState iblockdata = null;
 
-- 
2.18.0

